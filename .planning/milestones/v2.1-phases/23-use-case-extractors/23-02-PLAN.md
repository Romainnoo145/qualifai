---
phase: 23-use-case-extractors
plan: 02
type: execute
wave: 2
depends_on: ['23-01']
files_modified:
  - lib/codebase-analyzer.ts
  - server/routers/use-cases.ts
  - app/admin/use-cases/page.tsx
autonomous: true

must_haves:
  truths:
    - 'Admin can trigger codebase analysis from the Use Cases page and see created/skipped counts'
    - 'Codebase analyzer scans project directories for key files, uses AI to extract capability descriptions, and creates UseCase records'
    - 'Re-running codebase import never creates duplicates (sourceRef dedup)'
    - 'Extracted use cases appear in the Use Cases admin list immediately after import'
  artifacts:
    - path: 'lib/codebase-analyzer.ts'
      provides: 'Project directory scanning, AI-powered capability extraction'
      exports: ['analyzeCodebase']
    - path: 'server/routers/use-cases.ts'
      provides: 'importFromCodebase tRPC procedure'
      contains: 'importFromCodebase'
    - path: 'app/admin/use-cases/page.tsx'
      provides: 'Analyze Codebase button with path input and result feedback'
      contains: 'importFromCodebase'
  key_links:
    - from: 'app/admin/use-cases/page.tsx'
      to: 'server/routers/use-cases.ts'
      via: 'tRPC mutation api.useCases.importFromCodebase'
      pattern: "importFromCodebase\\.mutate"
    - from: 'server/routers/use-cases.ts'
      to: 'lib/codebase-analyzer.ts'
      via: 'analyzeCodebase function call'
      pattern: 'analyzeCodebase'
    - from: 'lib/codebase-analyzer.ts'
      to: 'Gemini AI'
      via: 'getGenerativeModel for capability extraction'
      pattern: 'generateContent'
---

<objective>
Build a codebase analyzer that scans a project directory for key source files (README, package.json, BUSINESS_INTENT.md, route files, etc.), uses Gemini AI to extract descriptions of capabilities the project delivers, and creates UseCase records with dedup. Wire to admin UI with path input and trigger button.

Purpose: SEED-02 — Admin can extract use cases from project codebases, capturing service capabilities that exist in code but not yet in the use case catalog.
Output: `lib/codebase-analyzer.ts` module, `importFromCodebase` tRPC procedure, UI input+button on Use Cases page.
</objective>

<execution_context>
@/home/klarifai/.claude/get-shit-done/workflows/execute-plan.md
@/home/klarifai/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@server/routers/use-cases.ts
@lib/workflow-engine.ts (ProofCandidate interface, lazy singleton pattern for AI clients)
@app/admin/use-cases/page.tsx
@prisma/schema.prisma (UseCase model)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create codebase analyzer module with AI extraction</name>
  <files>lib/codebase-analyzer.ts</files>
  <action>
Create `lib/codebase-analyzer.ts` that exports `analyzeCodebase(projectPath: string): Promise<CodebaseAnalysisResult>`.

**File discovery strategy:**

The analyzer should look for HIGH-SIGNAL files in a project directory that reveal what the project does for end users. Prioritize (in order):

1. **Project manifest** — `package.json` (name, description, scripts), `pyproject.toml` (name, description), `Cargo.toml`
2. **README** — `README.md` or `readme.md` in project root
3. **Business context** — files matching `**/BUSINESS_INTENT.md`, `**/USER_WORKFLOWS.md`, `**/DOMAIN_MODEL.md` (Obsidian Forge convention)
4. **API surface** — files matching `**/app/api/**/route.ts`, `**/server/routers/*.ts`, `**/routes/*.py`, `**/api/*.py` (first 10 found)
5. **Key config** — `.env.example` (reveals integrations via env vars)

For each file type, read content and truncate at 3000 chars. Skip `node_modules`, `.git`, `dist`, `build`, `.next`, `__pycache__` directories.

If the project path doesn't exist, return early with error. If no files found, return early with empty candidates.

**AI extraction:**

Assemble all discovered file contents into a single prompt context (with file path headers). Call Gemini (`gemini-2.0-flash` via `@google/generative-ai`, lazy singleton pattern same as workflow-engine.ts) with prompt:

```
Analyze this project codebase and extract the distinct SERVICE CAPABILITIES it delivers to end users or clients. This is a Klarifai project — focus on what business value it provides.

For each capability, provide:
- title: Short service name (e.g. "AI Content Generation", "Social Media Scheduling")
- summary: 2-3 sentence description of what this capability does and what problem it solves for clients
- category: One of: automation, content, analytics, crm, integration, design, development
- outcomes: Array of measurable business outcomes this capability delivers
- tags: Relevant keywords for matching against prospect pain points

Return ONLY a JSON array. If this codebase has no client-facing capabilities, return [].

Project files:
{assembled content}
```

Parse the JSON response. Handle malformed JSON gracefully (try to extract JSON array from response text with regex, same as scoreWithClaude in workflow-engine.ts).

**Return type:**

```typescript
interface CodebaseAnalysisResult {
  candidates: Array<{
    title: string;
    summary: string;
    category: string;
    outcomes: string[];
    tags: string[];
    sourceRef: string; // "codebase:" + projectPath basename
  }>;
  filesAnalyzed: number;
  projectName: string; // from package.json name or directory basename
  errors: string[];
}
```

All candidates from one project share the same sourceRef prefix (`codebase:project-name`), but each gets a unique sourceRef by appending a slug of the title: `codebase:project-name:slugified-title`.

**Error handling:** If Gemini fails, return empty candidates with descriptive error. Use `process.env.GOOGLE_AI_API_KEY` directly (not env.mjs) for testability.
</action>
<verify>
Run `npx tsc --noEmit` — zero type errors. Verify the file exports analyzeCodebase and CodebaseAnalysisResult.
</verify>
<done>
lib/codebase-analyzer.ts exists, exports analyzeCodebase that discovers key project files, sends to Gemini for capability extraction, returns typed CodebaseAnalysisResult.
</done>
</task>

<task type="auto">
  <name>Task 2: Wire importFromCodebase tRPC procedure and UI</name>
  <files>server/routers/use-cases.ts, app/admin/use-cases/page.tsx</files>
  <action>
**tRPC procedure (`server/routers/use-cases.ts`):**

Add `importFromCodebase` adminProcedure mutation. Input: `z.object({ projectPath: z.string().min(1) })`. Implementation:

1. Import `analyzeCodebase` from `@/lib/codebase-analyzer`.
2. Call `analyzeCodebase(input.projectPath)`.
3. For each candidate: check `ctx.db.useCase.findFirst({ where: { sourceRef: candidate.sourceRef } })`. If exists, increment skipped. If not, create UseCase record. isActive: true, isShipped: true.
4. Return `{ created, skipped, filesAnalyzed, projectName, errors }`.

Pattern: Same as importFromObsidian and importFromVault — sourceRef dedup, created/skipped counting.

**NOTE:** Plan 23-01 runs first (Wave 1) and adds `importFromVault` to the same files. When implementing this plan, 23-01's changes will already be present. Add importFromCodebase after importFromVault in the router. In the UI, add the codebase section below 23-01's "Scan Vault" button.

**Admin UI (`app/admin/use-cases/page.tsx`):**

1. Add state for codebase path: `const [codebasePath, setCodebasePath] = useState('')`.
2. Add mutation hook: `const codebaseImportMutation = api.useCases.importFromCodebase.useMutation(...)` — invalidate list on success, show alert with results.
3. Below the header buttons row, add a compact "Analyze Codebase" section:
   - A text input (using existing inputClass style or inline Tailwind) for the project directory path, placeholder: `/home/klarifai/Documents/klarifai/projects/copifai`.
   - A button labeled "Analyze Codebase" with `CodeXml` icon from lucide-react. Disabled when path is empty or mutation is pending.
   - This section should be collapsible — hidden by default behind a toggle link "Analyze a project codebase..." that expands to show the input and button.
4. Success alert: "Analyzed {projectName} ({filesAnalyzed} files). Created {created} use cases, skipped {skipped} duplicates." plus any errors.

The collapsible section avoids cluttering the page when not in use. Use a simple `showCodebaseForm` boolean state toggle.
</action>
<verify>
Run `npx tsc --noEmit` — zero type errors. Verify the Use Cases page renders with the codebase analyzer toggle and form. Check that submitting a path calls the importFromCodebase mutation.
</verify>
<done>
importFromCodebase tRPC procedure accepts projectPath, analyzes codebase via AI, creates UseCase records with dedup. Use Cases page has collapsible codebase analyzer section with path input and trigger button.
</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run lint` passes (or only pre-existing warnings)
3. `lib/codebase-analyzer.ts` exports analyzeCodebase
4. `server/routers/use-cases.ts` has importFromCodebase procedure
5. `app/admin/use-cases/page.tsx` has collapsible codebase analyzer section
6. UseCase records created via codebase import have sourceRef starting with "codebase:" for dedup
</verification>

<success_criteria>

- Codebase analyzer scans project directory for high-signal files
- AI extraction produces service capability candidates from project code
- UseCase records created with sourceRef dedup (no duplicates on re-run)
- Admin sees results: projectName, filesAnalyzed, created, skipped counts
- All extracted use cases appear in Use Cases admin list
  </success_criteria>

<output>
After completion, create `.planning/phases/23-use-case-extractors/23-02-SUMMARY.md`
</output>
