---
phase: 15-action-queue-dashboard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/routers/admin.ts
autonomous: true

must_haves:
  truths:
    - 'A single tRPC query returns all pending action items across hypotheses, drafts, touch tasks, and replies with counts per type'
    - 'Overdue touch tasks are identified by comparing dueAt metadata to current time'
    - 'Each action item includes enough context (prospect name, company, type, age) to render a queue row'
  artifacts:
    - path: 'server/routers/admin.ts'
      provides: 'getActionQueue tRPC query'
      contains: 'getActionQueue'
  key_links:
    - from: 'server/routers/admin.ts'
      to: 'prisma.workflowHypothesis'
      via: 'findMany with status DRAFT'
      pattern: "workflowHypothesis\\.findMany"
    - from: 'server/routers/admin.ts'
      to: 'prisma.outreachLog'
      via: 'findMany for drafts, touch tasks, and replies'
      pattern: "outreachLog\\.findMany"
---

<objective>
Add a `getActionQueue` tRPC query to the admin router that aggregates all pending admin decisions into a single response: DRAFT hypotheses needing review, outreach drafts awaiting approval, open touch tasks (calls/LinkedIn/WhatsApp) with overdue detection, and unhandled inbound replies.

Purpose: The dashboard UI (Plan 02) needs a single data source that provides all action items with counts and urgency indicators. Fetching four separate queries from the dashboard would cause waterfall loading and duplicated logic.

Output: New `getActionQueue` procedure in `server/routers/admin.ts`
</objective>

<execution_context>
@/home/klarifai/.claude/get-shit-done/workflows/execute-plan.md
@/home/klarifai/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@server/routers/admin.ts
@server/routers/hypotheses.ts
@server/routers/outreach.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add getActionQueue tRPC query to admin router</name>
  <files>server/routers/admin.ts</files>
  <action>
Add a new `getActionQueue` adminProcedure query at the end of the admin router (after `getDashboardStats`). This query runs four parallel Prisma queries via `Promise.all`:

1. **DRAFT hypotheses** — `ctx.db.workflowHypothesis.findMany` where `status: 'DRAFT'`, ordered by `createdAt: 'asc'` (oldest first = most urgent), take 50. Include `prospect: { select: { id, companyName, domain } }`. Map each to: `{ id, type: 'hypothesis' as const, prospectId, prospectName: prospect.companyName ?? prospect.domain, title, createdAt, urgency: 'normal' as const }`.

2. **Draft outreach logs** — `ctx.db.outreachLog.findMany` where `status: 'draft'`, ordered by `createdAt: 'asc'`, take 50. Include `contact: { include: { prospect: { select: { id, companyName, domain } } } }`. Map each to: `{ id, type: 'draft' as const, prospectId: contact.prospect.id, prospectName: contact.prospect.companyName ?? contact.prospect.domain, title: subject ?? 'Untitled draft', createdAt, urgency: 'normal' as const }`.

3. **Open touch tasks** — `ctx.db.outreachLog.findMany` where `status: 'touch_open'`, `channel: { in: ['call', 'linkedin', 'whatsapp', 'email'] }`, ordered by `createdAt: 'asc'`, take 50. Include same contact+prospect shape. For each task, extract `dueAt` from metadata JSON (same pattern as `getTouchTaskMetadata` in outreach.ts — check if `metadata` is object, get `dueAt` string, parse as Date). Mark `urgency: 'overdue'` if dueAt is in the past, `'normal'` otherwise. Map each to: `{ id, type: 'task' as const, prospectId, prospectName, title: subject ?? 'Follow-up task', channel: log.channel, createdAt, urgency, dueAt: parsedDueAt?.toISOString() ?? null }`.

4. **Pending replies** — `ctx.db.outreachLog.findMany` where `type: 'FOLLOW_UP'`, `status: 'received'`, ordered by `createdAt: 'asc'`, take 50. Include same contact+prospect shape. Map each to: `{ id, type: 'reply' as const, prospectId, prospectName, title: subject ?? 'Inbound reply', createdAt, urgency: 'normal' as const }`.

Merge all four arrays into a single `items` array. Sort by: overdue items first (urgency === 'overdue'), then by createdAt ascending (oldest first).

Return shape:

```ts
{
  items: Array<{
    id: string;
    type: 'hypothesis' | 'draft' | 'task' | 'reply';
    prospectId: string;
    prospectName: string;
    title: string;
    createdAt: Date;
    urgency: 'overdue' | 'normal';
    channel?: string;
    dueAt?: string | null;
  }>;
  counts: {
    hypotheses: number; // total DRAFT hypotheses (from query 1 length)
    drafts: number; // total draft outreach logs (from query 2 length)
    tasks: number; // total open touch tasks (from query 3 length)
    overdueTasks: number; // tasks with urgency === 'overdue'
    replies: number; // total pending replies (from query 4 length)
    total: number; // sum of all
  }
}
```

Use a helper function `parseDueAt(metadata: unknown): Date | null` at the top of the file (or reuse the pattern from outreach.ts — extract metadata as object, get dueAt string, parse as Date, return null if invalid). Do NOT import from outreach.ts to avoid circular dependencies — just duplicate the small helper.

IMPORTANT: Do not modify or remove any existing procedures. Only add the new one.
</action>
<verify>
Run `npm run check` — must pass with no TypeScript errors. The new procedure should be visible in the router type.
</verify>
<done>
`api.admin.getActionQueue.useQuery()` is callable from any admin page and returns items + counts for all four action types with overdue detection on touch tasks.
</done>
</task>

</tasks>

<verification>
1. `npm run check` passes with no errors
2. The `getActionQueue` procedure exists in admin router
3. Return type includes `items` array and `counts` object
</verification>

<success_criteria>

- Single tRPC query aggregates hypotheses, drafts, tasks, and replies
- Each item has type, prospectId, prospectName, title, createdAt, urgency
- Touch tasks with past dueAt are marked urgency: 'overdue'
- Counts object has per-type totals plus overdueTasks
  </success_criteria>

<output>
After completion, create `.planning/phases/15-action-queue-dashboard/15-01-SUMMARY.md`
</output>
