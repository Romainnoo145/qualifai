---
phase: 26.1-evidence-pipeline-expansion
plan: 03
type: execute
wave: 2
depends_on: [26.1-01]
files_modified:
  - lib/enrichment/linkedin-posts.ts
  - lib/research-executor.ts
autonomous: true
requirements: [EXP-05]

must_haves:
  truths:
    - 'LinkedIn posts evidence items with LINKEDIN sourceType appear after running pipeline on a prospect with a public LinkedIn company page'
    - "When LinkedIn returns zero posts (auth wall or blocking), a LINKEDIN evidence item is still recorded marking the attempt as 'not found'"
    - 'LinkedIn scraping failure does NOT halt the pipeline'
    - 'The existing Apollo-derived LinkedIn WEBSITE evidence items continue to work alongside new LINKEDIN post items'
  artifacts:
    - path: 'lib/enrichment/linkedin-posts.ts'
      provides: 'fetchLinkedInPosts — Scrapling StealthyFetcher scrape of public company posts, returns EvidenceDraft[]'
      min_lines: 60
    - path: 'lib/research-executor.ts'
      provides: 'LinkedIn posts wired into pipeline, replacing Crawl4AI LinkedIn attempt; empty-result recording added'
  key_links:
    - from: 'lib/enrichment/linkedin-posts.ts'
      to: 'lib/enrichment/scrapling.ts'
      via: 'fetchStealth import'
      pattern: 'fetchStealth'
    - from: 'lib/research-executor.ts'
      to: 'lib/enrichment/linkedin-posts.ts'
      via: 'fetchLinkedInPosts import + call'
      pattern: 'fetchLinkedInPosts'
---

<objective>
Add LinkedIn company posts as a new evidence source using Scrapling StealthyFetcher on public company pages, with proper empty-result recording and failure isolation.

Purpose: LinkedIn posts reveal company positioning, recent campaigns, and pain signals (what they're promoting = what they lack internally). This is the highest-signal LinkedIn evidence beyond Apollo profile data. Plan 03 runs parallel to Plan 02 (different files except research-executor.ts coordination is handled by wave sequencing).

Output: linkedin-posts.ts enrichment module + integration into research-executor.ts.
</objective>

<execution_context>
@/home/klarifai/.claude/get-shit-done/workflows/execute-plan.md
@/home/klarifai/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/26.1-evidence-pipeline-expansion/26.1-CONTEXT.md

Key files:
@lib/enrichment/scrapling.ts
@lib/research-executor.ts
@lib/web-evidence-adapter.ts
@.planning/phases/26.1-evidence-pipeline-expansion/26.1-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: LinkedIn posts module via Scrapling</name>
  <files>lib/enrichment/linkedin-posts.ts</files>
  <action>
Create `lib/enrichment/linkedin-posts.ts`. Scrapes the public company page `/recent-activity/posts/` path using Scrapling StealthyFetcher.

**Interface:**

```typescript
import { fetchStealth } from '@/lib/enrichment/scrapling';
import type { EvidenceDraft } from '@/lib/workflow-engine';

export async function fetchLinkedInPosts(input: {
  linkedinUrl: string;
  companyName: string | null;
}): Promise<EvidenceDraft[]>;
```

**Implementation:**

1. Build the posts URL: normalize `linkedinUrl` to company page root, then append `/posts/`:

```typescript
// Normalize: strip trailing slash, query params, then append /posts/
const baseUrl = input.linkedinUrl.replace(/\/+$/, '').split('?')[0];
const postsUrl = `${baseUrl}/posts/`;
```

2. Fetch with `fetchStealth(postsUrl)`. If `!result.ok || result.html.length < 300`: return []

3. **Authwall detection** (same pattern as current Crawl4AI LinkedIn logic in research-executor.ts):

```typescript
const isAuthwall =
  result.html.length < 500 ||
  [
    'authwall',
    'log in to linkedin',
    'join linkedin',
    'sign in',
    'leden login',
  ].some((phrase) => result.html.toLowerCase().includes(phrase));
if (isAuthwall) return [];
```

4. **Extract post text snippets** — LinkedIn's public posts pages render post content in `<span>` elements within article containers. Use regex to find text content between common LinkedIn post HTML patterns. Strategy:
   - Strip script/style tags: `html.replace(/<script[\s\S]*?<\/script>/gi, '').replace(/<style[\s\S]*?<\/style>/gi, '')`
   - Find `<span>` content blocks: `html.match(/<span[^>]*>([\s\S]{80,600}?)<\/span>/g)`
   - Strip remaining HTML tags from matches
   - Normalize whitespace
   - Filter: `text.length >= 60 && text.length <= 500`
   - Exclude UI chrome text: skip if text includes common LinkedIn UI phrases (`"Volgers"`, `"Connect"`, `"Volg"`, `"Like"`, `"Reageer"`, `"Delen"`, `"Meer weergeven"`)

5. Deduplicate extracted snippets (set by first 80 chars lowercased)

6. Map to `EvidenceDraft` (one per post snippet, max 8):

```typescript
{
  sourceType: 'LINKEDIN',
  sourceUrl: postsUrl,
  title: `${input.companyName ?? 'Bedrijf'} - LinkedIn post`,
  snippet: snippet.slice(0, 500),
  workflowTag: 'workflow-context',
  confidenceScore: 0.73,
  metadata: { adapter: 'linkedin-posts-scrapling', source: 'linkedin-posts' },
}
```

7. If after all filtering no snippets remain: return []

8. Wrap entire function in try/catch — any error returns []

**Note:** LinkedIn blocking with StealthyFetcher is expected in many cases. Empty return is a valid outcome — the research-executor caller handles empty-result recording.
</action>
<verify>
<automated>cd /home/klarifai/Documents/klarifai/projects/qualifai && npx tsc --noEmit 2>&1 | grep "linkedin-posts" | head -5</automated>
<manual>Check lib/enrichment/linkedin-posts.ts exports fetchLinkedInPosts; verify authwall detection present; verify try/catch wraps everything; verify sourceType is 'LINKEDIN' not 'WEBSITE'</manual>
</verify>
<done>lib/enrichment/linkedin-posts.ts exists, exports fetchLinkedInPosts returning Promise&lt;EvidenceDraft[]&gt;, uses fetchStealth, authwall detection, sourceType='LINKEDIN', no TypeScript errors</done>
</task>

<task type="auto">
  <name>Task 2: Wire LinkedIn posts into research-executor + empty-result recording</name>
  <files>lib/research-executor.ts</files>
  <action>
Integrate `fetchLinkedInPosts` into `executeResearchRun` in `lib/research-executor.ts`.

**1. Add import:**

```typescript
import { fetchLinkedInPosts } from '@/lib/enrichment/linkedin-posts';
```

**2. Add 'linkedin_posts' to SourceDiagnostic union** (alongside existing 'linkedin'):

```typescript
source: ... | 'linkedin_posts';
```

**3. Replace the existing Crawl4AI LinkedIn block** with the new LinkedIn posts approach. The current code at the bottom of the `if (input.deepCrawl)` block does:

```typescript
// LinkedIn browser extraction attempt (EVID-08 — best-effort, often blocked by authwall)
if (input.deepCrawl && prospect.linkedinUrl) {
  try {
    const { markdown, title } = await extractMarkdown(prospect.linkedinUrl);
    // ...authwall check... allDrafts.push(...)
  } catch { ... }
}
```

Replace this with `fetchLinkedInPosts`:

```typescript
// LinkedIn company posts via Scrapling (replaces Crawl4AI LinkedIn extraction)
if (input.deepCrawl && prospect.linkedinUrl) {
  try {
    const linkedinPostDrafts = await fetchLinkedInPosts({
      linkedinUrl: prospect.linkedinUrl,
      companyName: prospect.companyName,
    });
    allDrafts.push(...linkedinPostDrafts);
    // Empty result recording — always record the attempt (distinguishes "not found" from "not tried")
    if (linkedinPostDrafts.length === 0) {
      allDrafts.push({
        sourceType: 'LINKEDIN',
        sourceUrl: prospect.linkedinUrl,
        title: `${prospect.companyName ?? prospect.domain} - LinkedIn Posts (geen resultaten)`,
        snippet:
          'LinkedIn company posts page could not be scraped (auth wall or blocking).',
        workflowTag: 'workflow-context',
        confidenceScore: 0.1,
        metadata: { adapter: 'linkedin-posts-scrapling', notFound: true },
      });
    }
    diagnostics.push({
      source: 'linkedin_posts',
      status: linkedinPostDrafts.length > 0 ? 'ok' : 'warning',
      message:
        linkedinPostDrafts.length > 0
          ? `LinkedIn posts scraped ${linkedinPostDrafts.length} post snippets.`
          : 'LinkedIn posts page was blocked or empty; placeholder recorded.',
    });
  } catch (err) {
    console.error('[LinkedIn Posts] scrape failed:', err);
    diagnostics.push({
      source: 'linkedin_posts',
      status: 'error',
      message: `LinkedIn posts scrape failed: ${err instanceof Error ? err.message : 'Unknown error'}`,
    });
  }
} else if (!prospect.linkedinUrl) {
  diagnostics.push({
    source: 'linkedin_posts',
    status: 'skipped',
    message: 'LinkedIn posts skipped: no linkedinUrl on prospect.',
  });
}
```

**4. Keep the Apollo-derived LinkedIn evidence block unchanged** — it still runs unconditionally using DB fields (description, specialties, industry) and produces a LINKEDIN sourceType item (after Plan 01's `inferSourceType` fix, or keep it as-is since it uses explicit `sourceType: 'LINKEDIN'` after Plan 01).

Wait — check: the Apollo-derived block currently writes `sourceType: 'WEBSITE'`. After Plan 01's schema extension adds LINKEDIN, update this block to use `sourceType: 'LINKEDIN'`:

```typescript
// In Apollo-derived LinkedIn block
allDrafts.push({
  sourceType: 'LINKEDIN',  // was 'WEBSITE' — update to LINKEDIN post Plan 01
  sourceUrl: prospect.linkedinUrl ?? `https://www.linkedin.com/company/${prospect.domain.split('.')[0]}`,
  ...
```

**5. Add skipped diagnostic** in the `else` (deepCrawl=false) branch:

```typescript
diagnostics.push({
  source: 'linkedin_posts',
  status: 'skipped',
  message: 'LinkedIn posts skipped (deep crawl disabled).',
});
```

**6. Note on evidence cap:** Plan 02 already raises the cap to 48. This plan modifies research-executor.ts too — verify the cap is already 48 from Plan 02 (if plans run sequentially as wave structure requires, it will be). If this plan is creating the cap change for the first time, set it to 48.

Run `npm run check` — fix all TypeScript errors.
</action>
<verify>
<automated>cd /home/klarifai/Documents/klarifai/projects/qualifai && npm run check 2>&1 | tail -15</automated>
<manual>Grep research-executor.ts for fetchLinkedInPosts import; verify Apollo-derived block uses sourceType 'LINKEDIN'; verify notFound placeholder for empty posts; verify Crawl4AI LinkedIn block is replaced</manual>
</verify>
<done>npm run check passes; fetchLinkedInPosts imported and wired in deepCrawl block; Apollo-derived LinkedIn uses LINKEDIN sourceType; empty-result placeholder recorded when posts=0; Crawl4AI LinkedIn block replaced</done>
</task>

</tasks>

<verification>
1. `npm run check` — passes
2. `grep -n "fetchLinkedInPosts" lib/research-executor.ts` — import and call found
3. `grep -n "sourceType: 'LINKEDIN'" lib/research-executor.ts` — appears in both Apollo-derived and LinkedIn posts blocks
4. `grep -n "notFound: true" lib/research-executor.ts` — appears for LinkedIn posts placeholder
5. `grep -n "extractMarkdown.*linkedinUrl\|linkedin.*extractMarkdown" lib/research-executor.ts` — NOT found (Crawl4AI LinkedIn replaced)
6. `cat lib/enrichment/linkedin-posts.ts` — exports fetchLinkedInPosts, contains authwall detection
</verification>

<success_criteria>

- lib/enrichment/linkedin-posts.ts exists with fetchLinkedInPosts export
- LinkedIn posts wired into research-executor.ts inside deepCrawl block
- Apollo-derived LinkedIn evidence uses LINKEDIN sourceType (not WEBSITE)
- Empty posts result records a placeholder with confidenceScore 0.10 and notFound: true
- Crawl4AI LinkedIn extraction block is replaced by fetchLinkedInPosts
- LinkedIn blocking does not halt the pipeline
- npm run check passes
  </success_criteria>

<output>
After completion, create `.planning/phases/26.1-evidence-pipeline-expansion/26.1-03-SUMMARY.md`
</output>
