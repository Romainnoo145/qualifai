---
phase: 06-use-cases-foundation
plan: 03
type: execute
wave: 2
depends_on: ['06-01']
files_modified:
  - lib/workflow-engine.ts
  - lib/workflow-engine.test.ts
  - server/routers/proof.ts
  - server/routers/campaigns.ts
autonomous: true

must_haves:
  truths:
    - 'matchProofs() accepts a db parameter and queries UseCase records from the database'
    - 'Claude Haiku scores use cases against the query for semantic matching (NL and EN)'
    - 'Keyword-overlap fallback activates when Claude API call fails'
    - 'All four matchProofs() call sites (proof.ts x2, campaigns.ts x2) pass ctx.db'
    - 'Existing workflow-engine.test.ts passes with updated matchProofs signature'
    - 'Custom-plan fallback still works when no use cases exist in the database'
  artifacts:
    - path: 'lib/workflow-engine.ts'
      provides: 'DB-backed matchProofs with Claude semantic scoring'
      exports: ['matchProofs']
    - path: 'server/routers/proof.ts'
      provides: 'Updated matchProofs call sites with db parameter'
      contains: 'matchProofs(ctx.db'
    - path: 'server/routers/campaigns.ts'
      provides: 'Updated matchProofs call sites with db parameter'
      contains: 'matchProofs(ctx.db'
    - path: 'lib/workflow-engine.test.ts'
      provides: 'Updated test with mock db'
      contains: 'matchProofs'
  key_links:
    - from: 'lib/workflow-engine.ts'
      to: 'prisma/schema.prisma'
      via: 'db.useCase.findMany query'
      pattern: "db\\.useCase\\.findMany"
    - from: 'lib/workflow-engine.ts'
      to: '@anthropic-ai/sdk'
      via: 'Claude API call for semantic scoring'
      pattern: "anthropic\\.messages\\.create"
    - from: 'server/routers/proof.ts'
      to: 'lib/workflow-engine.ts'
      via: 'matchProofs(ctx.db, query, limit)'
      pattern: "matchProofs\\(ctx\\.db"
    - from: 'server/routers/campaigns.ts'
      to: 'lib/workflow-engine.ts'
      via: 'matchProofs(ctx.db, query, limit)'
      pattern: "matchProofs\\(ctx\\.db"
---

<objective>
Replace filesystem-based proof matching with database-backed UseCase queries and Claude-powered semantic scoring.

Purpose: This is the core intelligence upgrade — `matchProofs()` stops reading Obsidian JSON files and instead queries the UseCase table, using Claude Haiku for NL/EN semantic scoring. This fulfills UCASE-04 (AI-powered matching) and makes proof matching manageable from the admin UI.

Output: Updated `matchProofs()` function, all call sites updated, test updated, Claude scoring integrated.
</objective>

<execution_context>
@/home/klarifai/.claude/get-shit-done/workflows/execute-plan.md
@/home/klarifai/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-use-cases-foundation/06-RESEARCH.md
@.planning/phases/06-use-cases-foundation/06-01-SUMMARY.md

@lib/workflow-engine.ts (matchProofs current implementation, toTokens, ProofMatchResult interface, loadProofCatalog, scoreProof)
@lib/workflow-engine.test.ts (existing test with matchProofs call)
@server/routers/proof.ts (matchProofs call sites at lines 31, 56)
@server/routers/campaigns.ts (matchProofs call sites at lines 274, 300)
@lib/ai/generate-outreach.ts (reference pattern for Anthropic SDK usage — check model name used)
@env.mjs (ANTHROPIC_API_KEY)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite matchProofs() to query UseCase from DB with Claude semantic scoring</name>
  <files>lib/workflow-engine.ts</files>
  <action>
Modify `lib/workflow-engine.ts` to update the `matchProofs()` function:

1. **Add import** at the top of the file (with other imports):

```typescript
import type { PrismaClient } from '@prisma/client';
import Anthropic from '@anthropic-ai/sdk';
```

2. **Add Claude client** (after imports, before functions):

```typescript
const anthropic = new Anthropic({ apiKey: env.ANTHROPIC_API_KEY });
```

Note: Check existing `lib/ai/` files to see if there's a shared Anthropic client instance. If `lib/ai/generate-outreach.ts` or similar creates a shared client, import from there instead. If not, create it locally.

3. **Add `scoreWithClaude()` helper function** (private, above `matchProofs`):

```typescript
async function scoreWithClaude(
  useCases: Array<{
    id: string;
    title: string;
    summary: string;
    tags: string[];
    isShipped: boolean;
    externalUrl: string | null;
  }>,
  query: string,
  limit: number,
): Promise<ProofMatchResult[]> {
  try {
    const useCaseList = useCases
      .map(
        (uc, i) =>
          `${i + 1}. [${uc.id}] ${uc.title}: ${uc.summary}. Tags: ${uc.tags.join(', ')}`,
      )
      .join('\n');

    const response = await anthropic.messages.create({
      model: 'claude-haiku-4-5',
      max_tokens: 512,
      messages: [
        {
          role: 'user',
          content: `Score each use case for relevance to the prospect's pain point. Return ONLY a JSON array, no other text.

Pain point: ${query}

Use cases:
${useCaseList}

Return JSON array: [{"id": "...", "score": 0.0}]
Higher score = more relevant. 0.0 = no relevance. Be generous with partial matches — Dutch and English terms for the same concept should match (e.g., "facturering" matches "invoice automation").`,
        },
      ],
    });

    const text =
      response.content[0]?.type === 'text' ? response.content[0].text : '';
    const jsonMatch = text.match(/\[[\s\S]*\]/);
    if (!jsonMatch) throw new Error('No JSON array in response');

    const scores = JSON.parse(jsonMatch[0]) as Array<{
      id: string;
      score: number;
    }>;
    const scoreMap = new Map(scores.map((s) => [s.id, s.score]));

    return useCases
      .map((uc) => ({
        sourceType: 'use_case',
        proofId: uc.id,
        proofTitle: uc.title,
        proofSummary: uc.summary,
        proofUrl: uc.externalUrl,
        score: round2(scoreMap.get(uc.id) ?? 0),
        isRealShipped: uc.isShipped,
        isCustomPlan: false,
      }))
      .filter((m) => m.score > 0)
      .sort((a, b) => b.score - a.score)
      .slice(0, limit);
  } catch {
    // Fallback to keyword scoring if Claude fails
    return fallbackKeywordScore(useCases, query, limit);
  }
}
```

4. **Add keyword fallback function** (uses existing `toTokens` and `scoreProof` logic):

```typescript
function fallbackKeywordScore(
  useCases: Array<{
    id: string;
    title: string;
    summary: string;
    tags: string[];
    isShipped: boolean;
    externalUrl: string | null;
  }>,
  query: string,
  limit: number,
): ProofMatchResult[] {
  const queryTokens = toTokens(query);
  return useCases
    .map((uc) => {
      const candidateTokens = new Set(
        toTokens([uc.title, uc.summary, ...uc.tags].join(' ')),
      );
      const overlap = queryTokens.filter((t) => candidateTokens.has(t)).length;
      const score =
        queryTokens.length > 0 ? round2(overlap / queryTokens.length) : 0;
      return {
        sourceType: 'use_case',
        proofId: uc.id,
        proofTitle: uc.title,
        proofSummary: uc.summary,
        proofUrl: uc.externalUrl,
        score,
        isRealShipped: uc.isShipped,
        isCustomPlan: false,
      };
    })
    .filter((m) => m.score > 0)
    .sort((a, b) => b.score - a.score)
    .slice(0, limit);
}
```

5. **Update `matchProofs()` signature and implementation:**

Change from:

```typescript
export async function matchProofs(
  query: string,
  limit = 4,
): Promise<ProofMatchResult[]> {
  const catalog = await loadProofCatalog();
  // ... existing implementation ...
}
```

To:

```typescript
export async function matchProofs(
  db: PrismaClient,
  query: string,
  limit = 4,
): Promise<ProofMatchResult[]> {
  const useCases = await db.useCase.findMany({
    where: { isActive: true },
    select: {
      id: true,
      title: true,
      summary: true,
      tags: true,
      isShipped: true,
      externalUrl: true,
    },
  });

  if (useCases.length === 0) {
    return [
      {
        sourceType: 'custom',
        proofId: 'custom-plan',
        proofTitle: 'Custom build plan',
        proofSummary:
          'No direct shipped match found. Position as a tailored build informed by validated bottlenecks.',
        proofUrl: null,
        score: 0.2,
        isRealShipped: false,
        isCustomPlan: true,
      },
    ];
  }

  const results = await scoreWithClaude(useCases, query, limit);

  if (results.length === 0) {
    return [
      {
        sourceType: 'custom',
        proofId: 'custom-plan',
        proofTitle: 'Custom build plan',
        proofSummary:
          'No direct shipped match found. Position as a tailored build informed by validated bottlenecks.',
        proofUrl: null,
        score: 0.2,
        isRealShipped: false,
        isCustomPlan: true,
      },
    ];
  }

  return results;
}
```

6. **Do NOT delete** `loadProofCatalog()`, `scoreProof()`, `inventoryToCandidates()`, or `offersToCandidates()` — they are still used by the import procedure (Plan 06-01 exports them). Keep them in the file but they are no longer called from `matchProofs()`.

7. **Keep `ProofMatchResult` interface unchanged** — the shape is the same, only the source of data changes.

IMPORTANT: The `ProofMatch.create()` call in `proof.ts` and `campaigns.ts` stores `match.proofId` (which is now `uc.id`, a cuid). When a ProofMatch row is created from a DB-backed match, also set `useCaseId: match.proofId` so the FK link is established. This requires a small change at the call sites (see Task 2). For now, matchProofs just returns the data — the callers handle storage.
</action>
<verify>

1. `npx tsc --noEmit` passes for `lib/workflow-engine.ts`
2. matchProofs() accepts `(db, query, limit)` signature
3. scoreWithClaude falls back to keyword scoring on error
   </verify>
   <done>
   matchProofs() queries UseCase table from the database, uses Claude Haiku for semantic scoring with NL/EN support, falls back to keyword overlap on Claude failure, and returns custom-plan when no use cases exist.
   </done>
   </task>

<task type="auto">
  <name>Task 2: Update all matchProofs() call sites and add useCaseId to ProofMatch creation</name>
  <files>server/routers/proof.ts, server/routers/campaigns.ts</files>
  <action>
Update all four `matchProofs()` call sites to pass `ctx.db` as the first argument.

**In `server/routers/proof.ts`:**

Line 31 — change:

```typescript
const matches = await matchProofs(query, 4);
```

To:

```typescript
const matches = await matchProofs(ctx.db, query, 4);
```

Line 56 — change:

```typescript
const matches = await matchProofs(query, 4);
```

To:

```typescript
const matches = await matchProofs(ctx.db, query, 4);
```

Also update the `proofMatch.create()` calls (both for hypotheses and opportunities) to include `useCaseId` when the match is from the database (not a custom plan):

In both `proofMatch.create()` blocks, add:

```typescript
useCaseId: match.isCustomPlan ? undefined : match.proofId,
```

This links the new ProofMatch record to the UseCase via the FK. `match.proofId` contains the UseCase cuid when the match comes from the database.

**In `server/routers/campaigns.ts`:**

Line 274 — change:

```typescript
const matches = await matchProofs(
  `${hypothesis.title} ${hypothesis.problemStatement}`,
  4,
);
```

To:

```typescript
const matches = await matchProofs(
  ctx.db,
  `${hypothesis.title} ${hypothesis.problemStatement}`,
  4,
);
```

Line 300 — change:

```typescript
const matches = await matchProofs(
  `${opportunity.title} ${opportunity.description}`,
  4,
);
```

To:

```typescript
const matches = await matchProofs(
  ctx.db,
  `${opportunity.title} ${opportunity.description}`,
  4,
);
```

Also update both `proofMatch.create()` calls in campaigns.ts to include:

```typescript
useCaseId: match.isCustomPlan ? undefined : match.proofId,
```

Run `npm run check` after all changes. TypeScript will confirm all call sites are updated.
</action>
<verify>

1. `npm run check` passes (no TypeScript errors about matchProofs signature)
2. `grep -n "matchProofs(" server/routers/proof.ts server/routers/campaigns.ts` shows ctx.db in all 4 calls
3. Both routers include `useCaseId` in ProofMatch creation
   </verify>
   <done>
   All four matchProofs call sites pass ctx.db. ProofMatch creation includes useCaseId FK link for database-backed matches. npm run check passes.
   </done>
   </task>

<task type="auto">
  <name>Task 3: Update workflow-engine.test.ts for new matchProofs signature</name>
  <files>lib/workflow-engine.test.ts</files>
  <action>
Update `lib/workflow-engine.test.ts` to work with the new `matchProofs(db, query, limit)` signature.

1. **Create a mock db object** that returns an empty array for `useCase.findMany`. Add this near the top of the file (after the `vi.mock` block):

```typescript
const mockDb = {
  useCase: {
    findMany: vi.fn().mockResolvedValue([]),
  },
} as unknown as import('@prisma/client').PrismaClient;
```

2. **Update the matchProofs test** (the test at line ~136):

Change:

```typescript
const matches = await matchProofs('nonexistent-super-specific-query-token', 3);
```

To:

```typescript
const matches = await matchProofs(
  mockDb,
  'nonexistent-super-specific-query-token',
  3,
);
```

The test expects `isCustomPlan: true` and `proofTitle: 'Custom build plan'` — this behavior is preserved because `mockDb.useCase.findMany` returns `[]`, triggering the empty-catalog fallback in the new implementation.

3. **Also mock the Anthropic SDK** to prevent real API calls during tests. Add to the `vi.mock` section:

```typescript
vi.mock('@anthropic-ai/sdk', () => ({
  default: class {
    messages = {
      create: vi.fn().mockRejectedValue(new Error('test mock')),
    };
  },
}));
```

This ensures Claude is never called in tests. The keyword fallback activates instead, which is fine since the test verifies the empty-catalog custom-plan path.

Run `npm run test` to verify all existing tests still pass.
</action>
<verify>

1. `npm run test` passes — all existing tests in workflow-engine.test.ts pass
2. The matchProofs test still verifies custom-plan fallback behavior
3. No real Anthropic API calls during tests
   </verify>
   <done>
   workflow-engine.test.ts updated with mock db and mocked Anthropic SDK. All existing tests pass with the new matchProofs(db, query, limit) signature. npm run test passes.
   </done>
   </task>

</tasks>

<verification>
1. `npm run check` — TypeScript compiles with no errors across all modified files
2. `npm run test` — all existing tests pass including the updated matchProofs test
3. `grep -rn "matchProofs(" server/ lib/` — confirms all call sites use the new (db, query, limit) signature
4. No references to `loadProofCatalog()` remain in the matchProofs execution path
</verification>

<success_criteria>

- matchProofs(db, query, limit) queries UseCase records from the database
- Claude Haiku scores use cases semantically (works for both NL and EN queries)
- Keyword overlap fallback activates when Claude API fails
- All four call sites in proof.ts and campaigns.ts pass ctx.db
- ProofMatch creation includes useCaseId FK for DB-backed matches
- workflow-engine.test.ts passes with mock db
- npm run check and npm run test both pass
  </success_criteria>

<output>
After completion, create `.planning/phases/06-use-cases-foundation/06-03-SUMMARY.md`
</output>
