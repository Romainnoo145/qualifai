---
phase: 06-use-cases-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - prisma/migrations/YYYYMMDDHHMMSS_use_cases/migration.sql
  - server/routers/use-cases.ts
  - server/routers/_app.ts
autonomous: true

must_haves:
  truths:
    - 'UseCase model exists in the database with all required fields (title, summary, category, outcomes, tags, caseStudyRefs, isActive, isShipped, sourceRef)'
    - 'ProofMatch has an optional useCaseId FK pointing to UseCase'
    - 'tRPC useCases router exposes list, create, update, delete, and importFromObsidian procedures'
    - 'Importing Obsidian JSON files creates UseCase records with sourceRef for idempotency'
    - 'useCases router is registered in _app.ts and accessible via api.useCases.*'
  artifacts:
    - path: 'prisma/schema.prisma'
      provides: 'UseCase model and ProofMatch.useCaseId FK'
      contains: 'model UseCase'
    - path: 'server/routers/use-cases.ts'
      provides: 'CRUD + import router for use cases'
      exports: ['useCasesRouter']
    - path: 'server/routers/_app.ts'
      provides: 'Router registration'
      contains: 'useCases: useCasesRouter'
  key_links:
    - from: 'server/routers/use-cases.ts'
      to: 'prisma/schema.prisma'
      via: 'ctx.db.useCase queries'
      pattern: "ctx\\.db\\.useCase\\."
    - from: 'server/routers/_app.ts'
      to: 'server/routers/use-cases.ts'
      via: 'import and registration'
      pattern: 'useCases: useCasesRouter'
---

<objective>
Add the UseCase Prisma model with migration, create a tRPC CRUD + import router, and register it in the app router.

Purpose: Establishes the database-backed service catalog that replaces Obsidian JSON files. All downstream work (admin UI, proof matching) depends on this model and router existing.

Output: UseCase table in PostgreSQL, tRPC router with list/create/update/delete/importFromObsidian procedures, router registered in \_app.ts.
</objective>

<execution_context>
@/home/klarifai/.claude/get-shit-done/workflows/execute-plan.md
@/home/klarifai/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-use-cases-foundation/06-RESEARCH.md

@prisma/schema.prisma
@server/routers/\_app.ts
@server/routers/campaigns.ts (pattern reference for tRPC CRUD router)
@server/trpc.ts (adminProcedure definition)
@lib/workflow-engine.ts (inventoryToCandidates, offersToCandidates, ProofCandidate interface, readJsonSafe pattern)
@env.mjs (OBSIDIAN_INVENTORY_JSON_PATH, OBSIDIAN_CLIENT_OFFERS_JSON_PATH)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add UseCase model and ProofMatch FK to Prisma schema and run migration</name>
  <files>prisma/schema.prisma</files>
  <action>
Add a `UseCase` model to `prisma/schema.prisma` between the `ProofMatch` model and the `WorkflowLossMap` model (in the CORE MODELS section). Fields:

```prisma
model UseCase {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  title       String
  summary     String
  category    String
  outcomes    String[]
  tags        String[]
  caseStudyRefs String[]
  isActive    Boolean  @default(true)
  isShipped   Boolean  @default(true)
  sourceRef   String?
  externalUrl String?

  proofMatches ProofMatch[]

  @@index([isActive, isShipped])
  @@index([category])
}
```

Add to the existing `ProofMatch` model (after `evidenceItemId`/`evidenceItem` fields):

```prisma
  useCaseId   String?
  useCase     UseCase? @relation(fields: [useCaseId], references: [id], onDelete: SetNull)
```

Add an index for useCaseId to ProofMatch:

```prisma
  @@index([useCaseId])
```

IMPORTANT: Do NOT modify any existing ProofMatch fields. `proofId String?` and `proofTitle String` stay unchanged for backward compatibility with legacy JSON-backed records.

After editing schema.prisma, run:

```bash
npx prisma migrate dev --name use_cases
```

This generates the migration SQL file and applies it to the dev database.
</action>
<verify>

1. `npx prisma validate` exits 0 (schema is valid)
2. Migration file exists in `prisma/migrations/` with `use_cases` in the name
3. `npx prisma migrate status` shows no pending migrations
   </verify>
   <done>
   UseCase table exists in PostgreSQL with all specified columns. ProofMatch table has a nullable useCaseId FK column with an index. Migration applied cleanly.
   </done>
   </task>

<task type="auto">
  <name>Task 2: Create tRPC use-cases router with CRUD and Obsidian import, register in _app.ts</name>
  <files>server/routers/use-cases.ts, server/routers/_app.ts</files>
  <action>
Create `server/routers/use-cases.ts` following the exact pattern of `campaigns.ts` and `hypotheses.ts` (import `z` from zod, import `adminProcedure, router` from `../trpc`).

Procedures to implement:

**list** — adminProcedure, optional input `{ category?: string, isActive?: boolean, limit?: number (1-200, default 100) }`. Query `ctx.db.useCase.findMany` with conditional where filters, `orderBy: { updatedAt: 'desc' }`, `take: input?.limit ?? 100`, `include: { _count: { select: { proofMatches: true } } }`.

**getById** — adminProcedure, input `{ id: string }`. Return `ctx.db.useCase.findUniqueOrThrow({ where: { id } })`.

**create** — adminProcedure, input validated with zod:

- title: z.string().min(2)
- summary: z.string().min(10)
- category: z.string().min(2)
- outcomes: z.array(z.string()).default([])
- tags: z.array(z.string()).default([])
- caseStudyRefs: z.array(z.string()).default([])
- isActive: z.boolean().default(true)
- isShipped: z.boolean().default(true)
- externalUrl: z.string().url().optional().or(z.literal(''))
  Returns `ctx.db.useCase.create({ data: input })`. For externalUrl, convert empty string to null before creating.

**update** — adminProcedure, input with `id: z.string()` required, all other create fields optional. Destructure `{ id, ...data }`, call `ctx.db.useCase.update({ where: { id }, data })`. For externalUrl, convert empty string to null.

**delete** — adminProcedure, input `{ id: z.string() }`. Soft delete: `ctx.db.useCase.update({ where: { id }, data: { isActive: false } })`.

**importFromObsidian** — adminProcedure, no input. Implementation:

1. Import `readFile` from `node:fs/promises` and `env` from `@/env.mjs`
2. Read `env.OBSIDIAN_INVENTORY_JSON_PATH` and `env.OBSIDIAN_CLIENT_OFFERS_JSON_PATH`
3. Parse JSON using try/catch (return `{ created: 0, skipped: 0, errors: ['Could not read file: <path>'] }` on failure)
4. Re-use the `inventoryToCandidates()` and `offersToCandidates()` functions from `@/lib/workflow-engine` (they are already exported or can be imported — check if they need to be exported first; if not exported, export them)
5. For each `ProofCandidate`, check `ctx.db.useCase.findFirst({ where: { sourceRef: candidate.proofId } })`. If exists, increment `skipped`. Otherwise create:
   ```
   ctx.db.useCase.create({
     data: {
       title: candidate.title,
       summary: candidate.summary,
       category: 'workflow',
       tags: candidate.keywords,
       outcomes: [],
       caseStudyRefs: candidate.url ? [candidate.url] : [],
       isActive: true,
       isShipped: candidate.shipped,
       sourceRef: candidate.proofId,
       externalUrl: candidate.url,
     }
   })
   ```
   Increment `created`.
6. Return `{ created, skipped, errors }`

NOTE: `inventoryToCandidates` and `offersToCandidates` are currently module-private (not exported). They need to be exported from `lib/workflow-engine.ts`. Add `export` to both function declarations. Also export `readJsonSafe` since the import procedure needs it.

Then register the router in `server/routers/_app.ts`:

1. Add import: `import { useCasesRouter } from './use-cases';`
2. Add to the `router({})` object: `useCases: useCasesRouter,`
   Place it alphabetically between `signals` and `wizard`.

Run `npm run check` after both files are complete to verify TypeScript compilation.
</action>
<verify>

1. `npm run check` passes with no errors (TypeScript compiles, lint passes)
2. The router exports a `useCasesRouter` with list, getById, create, update, delete, importFromObsidian procedures
3. `_app.ts` includes `useCases: useCasesRouter` in the router registration
   </verify>
   <done>
   tRPC useCases router exists with all 6 procedures (list, getById, create, update, delete, importFromObsidian). Router is registered in \_app.ts. `inventoryToCandidates`, `offersToCandidates`, and `readJsonSafe` are exported from workflow-engine.ts. `npm run check` passes.
   </done>
   </task>

</tasks>

<verification>
1. `npx prisma validate` — schema is valid
2. `npx prisma migrate status` — no pending migrations
3. `npm run check` — TypeScript compiles, lint passes
4. `npm run test` — existing tests still pass (matchProofs signature unchanged in this plan)
</verification>

<success_criteria>

- UseCase model exists in database with title, summary, category, outcomes, tags, caseStudyRefs, isActive, isShipped, sourceRef, externalUrl columns
- ProofMatch has nullable useCaseId FK to UseCase
- tRPC useCases router is callable at api.useCases.list/create/update/delete/importFromObsidian
- Import procedure deduplicates by sourceRef
- npm run check passes
  </success_criteria>

<output>
After completion, create `.planning/phases/06-use-cases-foundation/06-01-SUMMARY.md`
</output>
