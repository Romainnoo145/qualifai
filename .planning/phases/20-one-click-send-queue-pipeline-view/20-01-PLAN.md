---
phase: 20-one-click-send-queue-pipeline-view
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/routers/outreach.ts
autonomous: true

must_haves:
  truths:
    - 'Clicking approveDraft twice (or in two tabs) does not send the email twice — second call returns CONFLICT error'
    - 'bulkApproveLowRisk with concurrent invocations skips already-claimed drafts instead of double-sending'
    - "If sendOutreachEmail throws, the draft reverts to 'draft' status and reappears in the queue for retry"
  artifacts:
    - path: 'server/routers/outreach.ts'
      provides: 'Idempotency guard on approveDraft and bulkApproveLowRisk'
      contains: 'updateMany'
  key_links:
    - from: 'server/routers/outreach.ts'
      to: 'prisma.outreachLog.updateMany'
      via: 'atomic status claim from draft to sending'
      pattern: 'updateMany.*status.*draft.*sending'
---

<objective>
Add idempotency guards to `approveDraft` and `bulkApproveLowRisk` mutations in `server/routers/outreach.ts` using Prisma's atomic `updateMany` with conditional `where` to prevent double-sends.

Purpose: SEND-02 requires that clicking the send button twice (or in two browser tabs) never sends the same email twice. This is the critical safety prerequisite before any one-click send UI is built. Without this guard, concurrent requests both pass `findUniqueOrThrow`, both call `sendOutreachEmail`, and the recipient gets duplicate emails.

Output: Both mutations use an atomic claim (`updateMany where status='draft' data status='sending'`) before calling `sendOutreachEmail`. Failed sends revert status to `'draft'` for retry.
</objective>

<execution_context>
@/home/klarifai/.claude/get-shit-done/workflows/execute-plan.md
@/home/klarifai/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-one-click-send-queue-pipeline-view/20-RESEARCH.md
@server/routers/outreach.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add idempotency guard to approveDraft mutation</name>
  <files>server/routers/outreach.ts</files>
  <action>
In `server/routers/outreach.ts`, modify the `approveDraft` mutation (currently at line ~496):

1. **Before** the existing `findUniqueOrThrow` call, add the atomic claim:

```typescript
// Step 1: Atomic claim — prevents double-send
const claimed = await ctx.db.outreachLog.updateMany({
  where: { id: input.id, status: 'draft' },
  data: { status: 'sending' },
});

if (claimed.count === 0) {
  throw new TRPCError({
    code: 'CONFLICT',
    message: 'Draft is already being sent. Please refresh the queue.',
  });
}
```

2. Import `TRPCError` from `@trpc/server` if not already imported.

3. Keep the existing `findUniqueOrThrow` call (to fetch full draft data after claiming).

4. **Wrap the `sendOutreachEmail` call** in a try/catch that reverts status on failure:
   - On `sendOutreachEmail` throw: revert status to `'draft'` (NOT `'manual_review'`) so the draft reappears in the queue for retry. This replaces the current catch block that sets `manual_review`.
   - On quality `blocked` check: revert to `'manual_review'` (keep existing behavior — quality blocks are permanent, not transient).
   - On success: keep existing `delete` behavior.
   - On `result.success === false` (send returned failure): keep existing `retry` status behavior.

5. The catch block for `sendOutreachEmail` failure changes from:

```typescript
// OLD: sets manual_review with error metadata
await ctx.db.outreachLog.update({
  where: { id: input.id },
  data: { status: 'manual_review', metadata: { ... } as never },
});
```

To:

```typescript
// NEW: revert to draft for retry (transient network errors should be retryable)
await ctx.db.outreachLog.update({
  where: { id: input.id },
  data: { status: 'draft' },
});
```

The quality-blocked branch KEEPS the existing `manual_review` behavior — quality blocks are not transient errors.
</action>
<verify>Run `npx tsc --noEmit` — zero errors. Grep for `updateMany` in `approveDraft` to confirm the guard is in place.</verify>
<done>approveDraft atomically claims draft as 'sending' before send, returns CONFLICT if already claimed, reverts to 'draft' on transient failure, keeps 'manual_review' on quality block.</done>
</task>

<task type="auto">
  <name>Task 2: Add idempotency guard to bulkApproveLowRisk mutation</name>
  <files>server/routers/outreach.ts</files>
  <action>
In `server/routers/outreach.ts`, modify the `bulkApproveLowRisk` mutation (currently at line ~590):

1. Inside the `for (const draft of lowRiskDrafts)` loop, **before** calling `sendOutreachEmail`, add the atomic claim per-draft:

```typescript
// Atomic claim per draft — skip if already claimed by concurrent request
const claimed = await ctx.db.outreachLog.updateMany({
  where: { id: draft.id, status: 'draft' },
  data: { status: 'sending' },
});

if (claimed.count === 0) {
  // Already claimed by concurrent request — skip, don't fail
  continue;
}
```

2. Update the catch block for `sendOutreachEmail` failure: revert status to `'draft'` (not `'manual_review'`) for transient errors, same pattern as approveDraft:

```typescript
catch (error) {
  failed += 1;
  failedIds.push(draft.id);
  await ctx.db.outreachLog.update({
    where: { id: draft.id },
    data: { status: 'draft' },
  });
  continue;
}
```

3. Keep the rest of the loop logic (markSequenceStepAfterSend, delete on success, retry on failure) unchanged.

4. The `scannedDrafts` and `lowRiskFound` counts stay the same. The `approved` count may be lower than `lowRiskFound` if some drafts were claimed by a concurrent request — this is correct behavior (STATE.md: "claimed-by-other items were skipped correctly").
   </action>
   <verify>Run `npx tsc --noEmit` — zero errors. Grep for `updateMany` in `bulkApproveLowRisk` to confirm per-draft guard.</verify>
   <done>bulkApproveLowRisk atomically claims each draft before sending, silently skips already-claimed drafts, reverts to 'draft' on transient failure.</done>
   </task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `grep -n "updateMany" server/routers/outreach.ts` shows two atomic claims (one in approveDraft, one in bulkApproveLowRisk)
3. `grep -n "CONFLICT" server/routers/outreach.ts` shows TRPCError throw in approveDraft
4. `grep -n "'sending'" server/routers/outreach.ts` shows status transition in both mutations
</verification>

<success_criteria>
Both approveDraft and bulkApproveLowRisk use Prisma updateMany atomic claim before calling sendOutreachEmail. Double-click or concurrent-tab scenarios are prevented at the database level.
</success_criteria>

<output>
After completion, create `.planning/phases/20-one-click-send-queue-pipeline-view/20-01-SUMMARY.md`
</output>
