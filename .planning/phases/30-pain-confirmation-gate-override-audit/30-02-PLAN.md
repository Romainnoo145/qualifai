---
phase: 30-pain-confirmation-gate-override-audit
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - prisma/migrations/20260302_add_gate_override_audit/migration.sql
  - server/routers/research.ts
autonomous: true
requirements: [AUDT-01, AUDT-02]

must_haves:
  truths:
    - 'GateOverrideAudit table exists in database with correct columns and constraints'
    - 'approveQuality mutation writes a GateOverrideAudit row when admin approves despite a failed gate'
    - 'Audit record includes gateType, reason, actor, gateSnapshot, researchRunId, prospectId'
    - 'GateOverrideAudit records cannot be cascade-deleted when a ResearchRun is deleted (onDelete: Restrict)'
    - 'listOverrideAudits query returns audit records for a given research run'
    - 'Double-approval does not create duplicate audit rows (idempotency guard via qualityApproved check)'
  artifacts:
    - path: 'prisma/schema.prisma'
      provides: 'GateOverrideAudit model with relations to ResearchRun and Prospect'
      contains: 'model GateOverrideAudit'
    - path: 'prisma/migrations/20260302_add_gate_override_audit/migration.sql'
      provides: 'SQL migration creating the GateOverrideAudit table'
      contains: 'CREATE TABLE'
    - path: 'server/routers/research.ts'
      provides: 'Extended approveQuality mutation + listOverrideAudits query'
      contains: 'listOverrideAudits'
  key_links:
    - from: 'prisma/schema.prisma'
      to: 'GateOverrideAudit'
      via: 'model definition with ResearchRun and Prospect relations'
      pattern: 'model GateOverrideAudit'
    - from: 'server/routers/research.ts'
      to: 'prisma.gateOverrideAudit.create'
      via: 'audit row creation in approveQuality'
      pattern: "gateOverrideAudit\\.create"
    - from: 'server/routers/research.ts'
      to: 'prisma.gateOverrideAudit.findMany'
      via: 'listOverrideAudits query'
      pattern: "gateOverrideAudit\\.findMany"
---

<objective>
Create the GateOverrideAudit schema model, run the migration, extend approveQuality to write audit records on gate bypass, and add a listOverrideAudits query.

Purpose: AUDT-01 requires a permanent audit table. AUDT-02 requires mandatory override reason persistence.
Output: Working database table, extended mutation, new query endpoint.
</objective>

<execution_context>
@/home/klarifai/.claude/get-shit-done/workflows/execute-plan.md
@/home/klarifai/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-pain-confirmation-gate-override-audit/30-RESEARCH.md
@prisma/schema.prisma
@server/routers/research.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add GateOverrideAudit model to Prisma schema and create migration</name>
  <files>prisma/schema.prisma, prisma/migrations/20260302_add_gate_override_audit/migration.sql</files>
  <action>
    1. Add `GateOverrideAudit` model to prisma/schema.prisma:
       - `id` (String @id @default(cuid()))
       - `createdAt` (DateTime @default(now()))
       - `gateType` (String) — values: 'quality' | 'pain' | 'quality+pain'
       - `reason` (String) — admin-entered text, min 12 chars enforced at mutation level
       - `actor` (String @default("admin")) — single-actor system
       - `gateSnapshot` (Json) — point-in-time gate state at bypass time
       - `researchRunId` (String) with FK to ResearchRun, onDelete: Restrict (prevents accidental audit deletion)
       - `prospectId` (String) with FK to Prospect, onDelete: Cascade (follows EvidenceItem pattern)
       - Indexes on researchRunId, prospectId, createdAt
    2. Add `gateOverrideAudits GateOverrideAudit[]` relation to both `ResearchRun` and `Prospect` models
    3. Create migration SQL file at prisma/migrations/20260302_add_gate_override_audit/migration.sql:
       - CREATE TABLE "GateOverrideAudit" with all columns
       - CREATE INDEX statements for researchRunId, prospectId, createdAt
       - ALTER TABLE for FK constraints (researchRunId → ResearchRun ON DELETE RESTRICT, prospectId → Prospect ON DELETE CASCADE)
    4. Apply migration via docker exec: `docker exec qualifai-db psql -U user -d qualifai -f -` piping the migration SQL
    5. Run `npx prisma generate` to regenerate the client
  </action>
  <verify>
    <automated>docker exec qualifai-db psql -U user -d qualifai -c "SELECT column_name, data_type FROM information_schema.columns WHERE table_name = 'GateOverrideAudit' ORDER BY ordinal_position;" && npx prisma generate 2>&1 | tail -3</automated>
    <manual>Verify GateOverrideAudit table has all expected columns: id, createdAt, gateType, reason, actor, gateSnapshot, researchRunId, prospectId</manual>
  </verify>
  <done>GateOverrideAudit table exists in database with correct columns, FK constraints (Restrict on ResearchRun, Cascade on Prospect), and indexes. Prisma client regenerated.</done>
</task>

<task type="auto">
  <name>Task 2: Extend approveQuality mutation and add listOverrideAudits query</name>
  <files>server/routers/research.ts</files>
  <action>
    1. In the `approveQuality` mutation (server/routers/research.ts):
       - After the existing `researchRun.update` call, add audit record creation logic
       - Read the current `qualityApproved` value from the pre-read (`currentRun`) — only write audit if `qualityApproved` was null (idempotency: first approval only, not re-approvals)
       - Extract gate data from `summary.gate`: `passed`, `confirmedPainTags`, `unconfirmedPainTags`
       - Determine `gateType`: check if quality gate failed (`!gatePassed`) and/or pain tags are unconfirmed (`unconfirmedPainTags.length > 0`):
         - Both: 'quality+pain'
         - Quality only: 'quality'
         - Pain only: 'pain'
         - Neither: do not write audit (no bypass occurred)
       - Need to also read `prospectId` from the run — extend the initial findUniqueOrThrow select to include `prospectId` and `qualityApproved`
       - Create GateOverrideAudit row: `{ researchRunId, prospectId, gateType, reason: overrideReason, actor: 'admin', gateSnapshot: { gate object with confirmedPainTags, unconfirmedPainTags } }`
       - Only create when a bypass is happening (gateType determined) AND `currentRun.qualityApproved === null` (first time)
    2. Also extend the existing 12-char reason guard: when pain tags are unconfirmed (even if quality gate passed), still require the 12-char reason. Adjust the guard condition:
       - Current: `input.approved && !gatePassed && overrideReason.length < 12`
       - New: `input.approved && (!gatePassed || unconfirmedPainTags.length > 0) && overrideReason.length < 12`
       - Update the error message to mention pain gate override as well
    3. Add `listOverrideAudits` query to the research router:
       - Input: `z.object({ runId: z.string() })`
       - Query: `ctx.db.gateOverrideAudit.findMany({ where: { researchRunId: input.runId }, orderBy: { createdAt: 'asc' } })`
       - Use `adminProcedure`
  </action>
  <verify>
    <automated>npm run check</automated>
    <manual>TypeScript compiles with zero errors; approveQuality mutation signature is backward-compatible</manual>
  </verify>
  <done>approveQuality writes GateOverrideAudit row on gate bypass with idempotency guard; listOverrideAudits query is available; 12-char reason guard extended to cover unconfirmed pain tags.</done>
</task>

</tasks>

<verification>
```bash
npm run check
docker exec qualifai-db psql -U user -d qualifai -c "SELECT column_name FROM information_schema.columns WHERE table_name = 'GateOverrideAudit';"
```
</verification>

<success_criteria>

- GateOverrideAudit table exists with correct schema (7 columns, 3 indexes, 2 FK constraints)
- approveQuality mutation creates audit rows on gate bypass, skips on clean approval
- Double-approval does not create duplicate audit rows
- listOverrideAudits returns audit records by runId
- npm run check passes
  </success_criteria>

<output>
After completion, create `.planning/phases/30-pain-confirmation-gate-override-audit/30-02-SUMMARY.md`
</output>
