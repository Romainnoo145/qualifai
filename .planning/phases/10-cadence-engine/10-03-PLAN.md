---
phase: 10-cadence-engine
plan: 03
type: execute
wave: 3
depends_on: ['10-02']
files_modified:
  - server/routers/outreach.ts
  - app/api/internal/cron/cadence-sweep/route.ts
  - server/routers/sequences.ts
autonomous: true

must_haves:
  truths:
    - 'Completing a touch task fires evaluateCadence for the linked sequence (fire-and-forget, never blocks completion)'
    - 'completeTouchTask resolves sequenceId from task metadata first, then falls back to contactId lookup'
    - 'Tasks without a linked sequence skip cadence evaluation silently'
    - 'POST /api/internal/cron/cadence-sweep requires x-cron-secret authorization and calls processDueCadenceSteps'
    - 'tRPC query getCadenceState returns cadence history and current state for a prospect'
  artifacts:
    - path: 'server/routers/outreach.ts'
      provides: 'completeTouchTask cadence hook'
      contains: 'evaluateCadence'
    - path: 'app/api/internal/cron/cadence-sweep/route.ts'
      provides: 'Cron POST endpoint for cadence sweep'
      contains: 'processDueCadenceSteps'
    - path: 'server/routers/sequences.ts'
      provides: 'getCadenceState tRPC query'
      contains: 'getCadenceState'
  key_links:
    - from: 'server/routers/outreach.ts'
      to: 'lib/cadence/engine.ts'
      via: 'completeTouchTask calls evaluateCadence after marking done'
      pattern: "evaluateCadence.*catch.*console\\.error"
    - from: 'app/api/internal/cron/cadence-sweep/route.ts'
      to: 'lib/cadence/engine.ts'
      via: 'cron calls processDueCadenceSteps'
      pattern: 'processDueCadenceSteps'
    - from: 'server/routers/sequences.ts'
      to: 'prisma.outreachStep'
      via: 'getCadenceState reads steps for a prospect'
      pattern: "outreachStep\\.findMany"
---

<objective>
Wire the cadence engine into the application: hook completeTouchTask to trigger cadence evaluation, create the cron route for scheduled sweeps, and add a tRPC query for the UI to read cadence state.

Purpose: The cadence engine functions exist but are not connected to anything. This plan wires them in three places: (1) after a touch task is completed, (2) on a cron schedule for due steps, (3) as a query for the admin UI. Together these fulfill CADNC-01, CADNC-03, CADNC-04, and CADNC-05.

Output: Modified outreach router, new cron route, new tRPC query endpoint.
</objective>

<execution_context>
@/home/klarifai/.claude/get-shit-done/workflows/execute-plan.md
@/home/klarifai/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/10-cadence-engine/10-02-SUMMARY.md
@server/routers/outreach.ts
@app/api/internal/cron/research-refresh/route.ts
@server/routers/sequences.ts
@lib/cadence/engine.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire completeTouchTask to evaluateCadence and add sequence resolution</name>
  <files>server/routers/outreach.ts</files>
  <action>
In `server/routers/outreach.ts`, at the end of the `completeTouchTask` mutation (after the `ctx.db.contact.update` call for `lastContactedAt`, before `return updated`):

1. Import at top of file:

```typescript
import { evaluateCadence, DEFAULT_CADENCE_CONFIG } from '@/lib/cadence/engine';
```

2. Add a `resolveSequenceId` helper function (inside or above the router, NOT exported — internal helper):

```typescript
async function resolveSequenceId(
  db: PrismaClient,
  contactId: string,
  metadata: Record<string, unknown>,
): Promise<string | null> {
  // Priority 1: explicit sequenceId in metadata (cadence-created tasks have this)
  const metaSeqId = metadata.outreachSequenceId;
  if (typeof metaSeqId === 'string' && metaSeqId) return metaSeqId;

  // Priority 2: look up most recent active sequence for this contact
  const seq = await db.outreachSequence.findFirst({
    where: { contactId, status: { notIn: ['CLOSED_LOST'] } },
    orderBy: { updatedAt: 'desc' },
    select: { id: true },
  });
  return seq?.id ?? null;
}
```

3. At the end of `completeTouchTask` mutation, after the contact update and before `return updated`:

```typescript
// Fire-and-forget: cadence evaluation must never block task completion
const seqId = await resolveSequenceId(ctx.db, task.contactId, metadata);
if (seqId) {
  evaluateCadence(ctx.db, seqId, DEFAULT_CADENCE_CONFIG).catch(console.error);
}
```

Note: `metadata` is already parsed at line ~1034 as `const metadata = metadataAsObject(task.metadata)`. Reuse that variable.

IMPORTANT: Use `.catch(console.error)` pattern — same as Phase 9 engagement triggers. If the cadence engine throws, the touch task completion must still succeed.
</action>
<verify>

1. `npm run check` passes — no type errors
2. Read `server/routers/outreach.ts` to confirm `evaluateCadence` is called after `contact.update` in completeTouchTask
3. Confirm `resolveSequenceId` checks metadata first, then falls back to DB lookup
   </verify>
   <done>
   completeTouchTask calls evaluateCadence with resolved sequenceId (metadata priority, contactId fallback) after every touch completion. Fire-and-forget pattern prevents blocking.
   </done>
   </task>

<task type="auto">
  <name>Task 2: Create cadence cron route and getCadenceState tRPC query</name>
  <files>app/api/internal/cron/cadence-sweep/route.ts, server/routers/sequences.ts</files>
  <action>
**Cron route** — Create `app/api/internal/cron/cadence-sweep/route.ts`:

Follow the EXACT pattern from `app/api/internal/cron/research-refresh/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import prisma from '@/lib/prisma';
import { env } from '@/env.mjs';
import { processDueCadenceSteps } from '@/lib/cadence/engine';

function isAuthorized(req: NextRequest): boolean {
  const provided = req.headers.get('x-cron-secret') ?? '';
  const expected = env.INTERNAL_CRON_SECRET ?? env.ADMIN_SECRET;
  return provided.length > 0 && provided === expected;
}

export async function POST(req: NextRequest) {
  if (!isAuthorized(req)) {
    return NextResponse.json(
      { error: 'Unauthorized cron request' },
      { status: 401 },
    );
  }

  const result = await processDueCadenceSteps(prisma);
  return NextResponse.json({ success: true, ...result });
}
```

No payload parsing needed — the sweep function handles everything internally.

**tRPC query** — Add `getCadenceState` to `server/routers/sequences.ts`:

Add a new query procedure that returns cadence history for a prospect. This is what the Phase 10-04 UI will consume.

```typescript
getCadenceState: adminProcedure
  .input(z.object({ prospectId: z.string() }))
  .query(async ({ ctx, input }) => {
    // Find all sequences for this prospect
    const sequences = await ctx.db.outreachSequence.findMany({
      where: { prospectId: input.prospectId },
      include: {
        steps: {
          orderBy: { stepOrder: 'asc' },
          select: {
            id: true,
            stepOrder: true,
            status: true,
            scheduledAt: true,
            triggeredBy: true,
            nextStepReadyAt: true,
            sentAt: true,
            metadata: true,
            createdAt: true,
          },
        },
        contact: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            primaryEmail: true,
            primaryPhone: true,
            linkedinUrl: true,
          },
        },
      },
      orderBy: { updatedAt: 'desc' },
    });

    // Get engagement signals from latest wizard session
    const wizardSession = await ctx.db.wizardSession.findFirst({
      where: { prospectId: input.prospectId },
      orderBy: { createdAt: 'desc' },
      select: { maxStepReached: true, pdfDownloaded: true },
    });

    // Compute cadence state summary for the most recent active sequence
    const activeSeq = sequences.find(s => s.status !== 'CLOSED_LOST');
    const completedSteps = activeSeq?.steps.filter(s => ['SENT', 'QUEUED'].includes(s.status)) ?? [];
    const pendingStep = activeSeq?.steps.find(s => s.status === 'DRAFTED') ?? null;

    return {
      sequences,
      engagementLevel: (wizardSession?.maxStepReached ?? 0) >= 3 || wizardSession?.pdfDownloaded ? 'high' : 'normal',
      summary: {
        touchCount: completedSteps.length,
        hasPendingStep: !!pendingStep,
        nextStepReadyAt: pendingStep?.nextStepReadyAt ?? null,
        nextChannel: pendingStep ? (metadataAsObject(pendingStep.metadata).channel as string ?? 'email') : null,
        isExhausted: activeSeq?.status === 'CLOSED_LOST',
      },
    };
  }),
```

If `sequences.ts` does not have a `metadataAsObject` helper, add one (same simple function as in outreach.ts):

```typescript
function metadataAsObject(value: unknown): Record<string, unknown> {
  if (!value || typeof value !== 'object' || Array.isArray(value)) return {};
  return value as Record<string, unknown>;
}
```

Make sure `z` (from zod) and `adminProcedure`/`router` are imported (they should already be in sequences.ts).

Also ensure the `sequences` router is registered in the main app router (check `server/routers/index.ts` or `server/root.ts` — it likely already is from Phase 9 or earlier).
</action>
<verify>

1. `npm run check` passes — no type errors
2. Cron route file exists at `app/api/internal/cron/cadence-sweep/route.ts`
3. `getCadenceState` query is accessible via tRPC (check router registration)
4. Confirm cron auth pattern matches research-refresh exactly
   </verify>
   <done>
   Cron route at `/api/internal/cron/cadence-sweep` processes due cadence steps with proper auth. tRPC `sequences.getCadenceState` returns cadence history, engagement level, and summary for a prospect.
   </done>
   </task>

</tasks>

<verification>
- `npm run check` passes
- completeTouchTask in outreach.ts calls evaluateCadence with fire-and-forget pattern
- Cron route exists and follows research-refresh auth pattern
- getCadenceState tRPC query returns sequences, engagement level, and cadence summary
</verification>

<success_criteria>
Three wiring points connected: (1) completeTouchTask -> evaluateCadence, (2) cron route -> processDueCadenceSteps, (3) tRPC query -> getCadenceState. All type-safe, all with proper error handling.
</success_criteria>

<output>
After completion, create `.planning/phases/10-cadence-engine/10-03-SUMMARY.md`
</output>
