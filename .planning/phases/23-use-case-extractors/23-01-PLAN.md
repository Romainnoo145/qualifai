---
phase: 23-use-case-extractors
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/vault-reader.ts
  - server/routers/use-cases.ts
  - env.mjs
  - app/admin/use-cases/page.tsx
autonomous: true

must_haves:
  truths:
    - 'Admin can trigger vault import from the Use Cases page and see created/skipped counts'
    - 'Vault reader scans Obsidian markdown files, extracts service capability descriptions via AI, and creates UseCase records'
    - 'Re-running vault import never creates duplicates (sourceRef dedup)'
    - 'Extracted use cases appear in the Use Cases admin list immediately after import'
  artifacts:
    - path: 'lib/vault-reader.ts'
      provides: 'Markdown scanning, AI extraction, UseCase candidate generation'
      exports: ['scanVaultForUseCases']
    - path: 'server/routers/use-cases.ts'
      provides: 'importFromVault tRPC procedure'
      contains: 'importFromVault'
    - path: 'app/admin/use-cases/page.tsx'
      provides: 'Import from Vault button with result feedback'
      contains: 'importFromVault'
  key_links:
    - from: 'app/admin/use-cases/page.tsx'
      to: 'server/routers/use-cases.ts'
      via: 'tRPC mutation api.useCases.importFromVault'
      pattern: "importFromVault\\.mutate"
    - from: 'server/routers/use-cases.ts'
      to: 'lib/vault-reader.ts'
      via: 'scanVaultForUseCases function call'
      pattern: 'scanVaultForUseCases'
    - from: 'lib/vault-reader.ts'
      to: 'Gemini AI'
      via: 'getGenerativeModel for capability extraction'
      pattern: 'generateContent'
---

<objective>
Build a vault reader that scans Obsidian markdown files from a configurable directory path, uses Gemini AI to extract service capability descriptions from the markdown content, and creates UseCase records with dedup. Wire it to the admin UI with a dedicated button.

Purpose: SEED-01 — Admin can import use cases from Obsidian vault without manual entry, populating the service catalog from existing Klarifai knowledge assets.
Output: `lib/vault-reader.ts` module, `importFromVault` tRPC procedure, UI button on Use Cases page.
</objective>

<execution_context>
@/home/klarifai/.claude/get-shit-done/workflows/execute-plan.md
@/home/klarifai/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@server/routers/use-cases.ts
@lib/workflow-engine.ts (ProofCandidate interface, inventoryToCandidates/offersToCandidates patterns, readJsonSafe)
@app/admin/use-cases/page.tsx
@env.mjs
@prisma/schema.prisma (UseCase model)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create vault reader module with AI extraction</name>
  <files>lib/vault-reader.ts, env.mjs</files>
  <action>
Create `lib/vault-reader.ts` that exports `scanVaultForUseCases(vaultPath: string): Promise<VaultScanResult>`.

**Environment:**

- Add `OBSIDIAN_VAULT_PATH` to env.mjs server schema (z.string().optional()) and runtimeEnv. This points to the Obsidian vault root, e.g. `/home/klarifai/Documents/obsidian/Nexus-Point`.

**Module implementation:**

1. **File discovery** — Recursively find all `.md` files under `vaultPath`. Use `node:fs/promises` readdir with recursive option. Filter out files smaller than 200 chars (too short to contain useful content). Cap at 100 files to prevent runaway processing. Prioritize files in directories containing `00_Context`, `The_Forge`, or `ATLAS` (these contain business knowledge). Skip files in `node_modules`, `.git`, `90_Archive` directories.

2. **Content batching** — Group files into batches of 5-8 files each. For each batch, concatenate the markdown content with file path headers. Each file's content should be truncated at 2000 chars to stay within token limits.

3. **AI extraction** — For each batch, call Gemini (use `@google/generative-ai` like workflow-engine.ts does, with lazy singleton pattern). Prompt should ask Gemini to extract distinct service capabilities/offerings that Klarifai delivers, returning JSON array:

```json
[
  {
    "title": "string — service name",
    "summary": "string — what this service does and what problem it solves (2-3 sentences)",
    "category": "string — one of: automation, content, analytics, crm, integration, design, development",
    "outcomes": ["string — measurable business outcomes"],
    "tags": ["string — relevant keywords"],
    "sourceFile": "string — which vault file this was extracted from"
  }
]
```

The prompt must instruct: only extract SERVICES that Klarifai offers to clients, not internal tools or infrastructure. Focus on capabilities described in BUSINESS_INTENT, USER_WORKFLOWS, project descriptions. Return empty array if no client-facing services found in the batch.

4. **Dedup candidates** — After all batches processed, deduplicate by title similarity (lowercase + trim comparison). Merge tags from duplicates.

5. **Return type:**

```typescript
interface VaultScanResult {
  candidates: Array<{
    title: string;
    summary: string;
    category: string;
    outcomes: string[];
    tags: string[];
    sourceRef: string; // "vault:" + sourceFile path (relative to vault root)
  }>;
  filesScanned: number;
  errors: string[];
}
```

**Error handling:** If Gemini fails on a batch, log the error, add to errors array, continue with next batch. If vault path doesn't exist or is empty, return early with empty candidates and descriptive error.

Follow the lazy singleton pattern from workflow-engine.ts for the Gemini client. Use `process.env.GOOGLE_AI_API_KEY` directly (not env.mjs) for testability — same pattern as serp.ts and crawl4ai.ts per MEMORY.md.
</action>
<verify>
Run `npx tsc --noEmit` — zero type errors. Verify the file exports scanVaultForUseCases and VaultScanResult.
</verify>
<done>
lib/vault-reader.ts exists, exports scanVaultForUseCases that recursively reads markdown, batches through Gemini, returns typed VaultScanResult with candidates array, filesScanned count, and errors.
</done>
</task>

<task type="auto">
  <name>Task 2: Wire importFromVault tRPC procedure and UI button</name>
  <files>server/routers/use-cases.ts, app/admin/use-cases/page.tsx</files>
  <action>
**tRPC procedure (`server/routers/use-cases.ts`):**

Add `importFromVault` adminProcedure mutation (no input needed — reads OBSIDIAN_VAULT_PATH from env). Implementation:

1. Import `scanVaultForUseCases` from `@/lib/vault-reader`.
2. Read `OBSIDIAN_VAULT_PATH` from env (or process.env for consistency). If not set, return `{ created: 0, skipped: 0, errors: ["OBSIDIAN_VAULT_PATH not configured"] }`.
3. Call `scanVaultForUseCases(vaultPath)`.
4. For each candidate: check `ctx.db.useCase.findFirst({ where: { sourceRef: candidate.sourceRef } })`. If exists, increment skipped. If not, create UseCase record with all fields mapped. Category from AI, isActive: true, isShipped: true (assume extracted services are live).
5. Return `{ created, skipped, filesScanned, errors }`.

Pattern: Follow the existing `importFromObsidian` procedure structure exactly — same created/skipped counting, same sourceRef dedup logic.

**Admin UI (`app/admin/use-cases/page.tsx`):**

1. Add a new mutation hook: `const vaultImportMutation = api.useCases.importFromVault.useMutation(...)` with same pattern as importMutation — invalidate list on success, show alert with results.
2. Add a second import button next to the existing "Import from Obsidian" button. Label it "Scan Vault". Use the `FolderSearch` icon from lucide-react. When clicked, call `vaultImportMutation.mutate()`.
3. The success alert should show: "Scanned {filesScanned} files. Created {created} use cases, skipped {skipped} duplicates." plus any errors.
4. Disable button while loading, show spinner same as existing import button.
   </action>
   <verify>
   Run `npx tsc --noEmit` — zero type errors. Verify the Use Cases page renders without errors. Check that both import buttons appear in the header.
   </verify>
   <done>
   importFromVault tRPC procedure creates UseCase records with dedup. "Scan Vault" button appears on Use Cases admin page, triggers import, shows created/skipped/filesScanned results in alert.
   </done>
   </task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run lint` passes (or only pre-existing warnings)
3. `lib/vault-reader.ts` exports scanVaultForUseCases
4. `server/routers/use-cases.ts` has importFromVault procedure
5. `app/admin/use-cases/page.tsx` has Scan Vault button wired to importFromVault mutation
6. UseCase records created via vault import have sourceRef starting with "vault:" for dedup
</verification>

<success_criteria>

- Vault reader scans markdown files from OBSIDIAN_VAULT_PATH
- AI extraction produces service capability candidates from vault content
- UseCase records created with sourceRef dedup (no duplicates on re-run)
- Admin sees results: filesScanned, created, skipped counts
- All extracted use cases appear in Use Cases admin list
  </success_criteria>

<output>
After completion, create `.planning/phases/23-use-case-extractors/23-01-SUMMARY.md`
</output>
