---
phase: 07-evidence-approval-gate
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/routers/hypotheses.ts
  - server/routers/assets.ts
  - server/routers/campaigns.ts
autonomous: true

must_haves:
  truths:
    - 'Regenerating hypotheses for a research run also creates ProofMatch records linking each hypothesis to matched use cases'
    - 'Querying hypotheses by prospect returns proofMatches with useCase and evidenceItem data, plus evidenceItems resolved from evidenceRefs JSON'
    - 'Querying all hypotheses across prospects returns results with prospect info and proofMatches with useCase data'
    - 'Attempting to queue an outreach draft for a prospect with no ACCEPTED hypothesis throws a PRECONDITION_FAILED TRPCError'
    - 'Running autopilot on a campaign skips prospects with no ACCEPTED hypothesis and reports blocked_hypothesis status'
  artifacts:
    - path: 'server/routers/hypotheses.ts'
      provides: 'regenerateForRun with matchProofs wiring, enriched listByProspect, new listAll procedure'
      contains: 'matchProofs'
    - path: 'server/routers/assets.ts'
      provides: 'Hypothesis approval gate in queueOutreachDraft'
      contains: 'PRECONDITION_FAILED'
    - path: 'server/routers/campaigns.ts'
      provides: 'Hypothesis approval gate in runAutopilot per-prospect loop'
      contains: 'blocked_hypothesis'
  key_links:
    - from: 'server/routers/hypotheses.ts'
      to: 'lib/workflow-engine.ts'
      via: 'matchProofs(ctx.db, query, limit) import'
      pattern: "matchProofs\\(ctx\\.db"
    - from: 'server/routers/assets.ts'
      to: 'WorkflowHypothesis'
      via: 'count query for ACCEPTED status check'
      pattern: "workflowHypothesis\\.count"
    - from: 'server/routers/campaigns.ts'
      to: 'WorkflowHypothesis'
      via: 'count query for ACCEPTED status in per-prospect loop'
      pattern: 'blocked_hypothesis'
---

<objective>
Wire matchProofs into hypothesis regeneration, enrich hypothesis queries with evidence and use case data, and add an outreach gate that blocks sequence generation until at least one hypothesis is approved.

Purpose: This is the backend foundation for Phase 7. Without matchProofs wiring, the review UI will show empty use case matches. Without the gate, outreach can be sent for prospects with no approved hypotheses — violating the core "evidence-backed" principle.

Output: Updated hypotheses router (regenerateForRun + matchProofs, enriched listByProspect, new listAll), hypothesis approval gate in assets.queueOutreachDraft and campaigns.runAutopilot.
</objective>

<execution_context>
@/home/klarifai/.claude/get-shit-done/workflows/execute-plan.md
@/home/klarifai/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-evidence-approval-gate/07-RESEARCH.md
@.planning/phases/06-use-cases-foundation/06-03-SUMMARY.md

@server/routers/hypotheses.ts
@server/routers/assets.ts
@server/routers/campaigns.ts
@server/routers/proof.ts
@lib/workflow-engine.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire matchProofs into regenerateForRun and enrich hypothesis queries</name>
  <files>server/routers/hypotheses.ts</files>
  <action>
Three changes to `server/routers/hypotheses.ts`:

**1. Wire matchProofs into regenerateForRun:**

Import `matchProofs` from `@/lib/workflow-engine`. After each `workflowHypothesis.create()` call inside the `for (const hypothesis of hypotheses)` loop (after line 105), add:

- Delete existing ProofMatch rows for the newly created hypothesis (defensive, same pattern as `proof.ts` lines 35-46)
- Call `matchProofs(ctx.db, \`${hypothesis.title} ${hypothesis.problemStatement}\`, 4)`
- Create ProofMatch records for each match, linking to the prospect and hypothesis. Use the exact data shape from `campaigns.ts` lines 287-302:
  ```
  { prospectId: run.prospectId, workflowHypothesisId: created.id, sourceType, proofId, proofTitle, proofSummary, proofUrl, score, isRealShipped, isCustomPlan, useCaseId: match.isCustomPlan ? undefined : match.proofId }
  ```
- Store the created hypothesis ID (the `.create()` return value) so it can be used for both the ProofMatch creation and the eventual return count.

**2. Enrich listByProspect with evidence + use case data:**

Update `listByProspect` to:

- Change `proofMatches: true` to include useCase and evidenceItem:
  ```typescript
  proofMatches: {
    include: {
      useCase: { select: { id: true, title: true, summary: true, category: true } },
      evidenceItem: { select: { id: true, sourceUrl: true, snippet: true, sourceType: true, workflowTag: true, title: true } },
    },
    orderBy: { score: 'desc' },
    take: 6,
  },
  ```
- After fetching hypotheses and opportunities, extract all evidenceRef IDs from `h.evidenceRefs` (JSON array of strings) and `o.evidenceRefs`, deduplicate, and bulk-fetch EvidenceItem records via `ctx.db.evidenceItem.findMany({ where: { id: { in: dedupedIds } } })`.
- Build an `evidenceById` Map keyed by ID.
- Return enriched results with `evidenceItems` array per hypothesis/opportunity:
  ```typescript
  {
    hypotheses: hypotheses.map(h => ({
      ...h,
      evidenceItems: (Array.isArray(h.evidenceRefs) ? (h.evidenceRefs as string[]) : [])
        .map(id => evidenceById.get(id)).filter(Boolean),
    })),
    opportunities: opportunities.map(o => ({
      ...o,
      evidenceItems: (Array.isArray(o.evidenceRefs) ? (o.evidenceRefs as string[]) : [])
        .map(id => evidenceById.get(id)).filter(Boolean),
    })),
  }
  ```

**3. Add listAll procedure:**

Add a new `listAll` adminProcedure after `listByProspect`. Input: optional `{ status?: 'DRAFT' | 'ACCEPTED' | 'REJECTED', limit?: number (1-200, default 100) }`. Query `workflowHypothesis.findMany` with:

- `where`: filter by status if provided
- `orderBy: { createdAt: 'desc' }`
- `take: input?.limit ?? 100`
- `include`:
  - `prospect: { select: { id: true, companyName: true, domain: true } }`
  - `proofMatches: { include: { useCase: { select: { id: true, title: true, category: true } } }, orderBy: { score: 'desc' }, take: 4 }`
- Return the array directly.

Do NOT add a separate evidenceRefs resolution to listAll — keep it lightweight for the list page. Evidence detail is only needed on the per-prospect detail view (listByProspect).
</action>
<verify>Run `npx tsc --noEmit` — no type errors in server/routers/hypotheses.ts. Confirm matchProofs import resolves. Confirm the file exports hypothesesRouter with listByProspect, listAll, setStatus, and regenerateForRun.</verify>
<done>regenerateForRun creates ProofMatch records after each hypothesis. listByProspect returns proofMatches with useCase + evidenceItem includes and resolved evidenceItems from JSON refs. listAll returns hypotheses with prospect info and proofMatches.</done>
</task>

<task type="auto">
  <name>Task 2: Add hypothesis approval gate to queueOutreachDraft and runAutopilot</name>
  <files>server/routers/assets.ts, server/routers/campaigns.ts</files>
  <action>
**1. Gate in assets.ts — queueOutreachDraft:**

Add `import { TRPCError } from '@trpc/server';` at top of assets.ts (if not already imported).

Inside `queueOutreachDraft` mutation, after the `[map, contact]` fetch (after line 264) and before the `appUrl` line (line 266), add:

```typescript
// Hypothesis approval gate — block outreach unless at least one hypothesis is approved
const approvedHypothesisCount = await ctx.db.workflowHypothesis.count({
  where: { prospectId: map.prospect.id, status: 'ACCEPTED' },
});
if (approvedHypothesisCount === 0) {
  throw new TRPCError({
    code: 'PRECONDITION_FAILED',
    message:
      'Outreach blocked: approve at least one hypothesis before generating sequences.',
  });
}
```

**2. Gate in campaigns.ts — runAutopilot:**

In the `results` type union (around line 207), add `'blocked_hypothesis'` to the status union:

```typescript
status: 'planned' |
  'completed' |
  'blocked_gate' |
  'blocked_hypothesis' |
  'no_hypotheses' |
  'no_contact' |
  'error';
```

In the per-prospect loop (inside `try` block, after the research gate check around line 264 and before the hypotheses/opportunities fetch around line 266), add:

```typescript
// Hypothesis approval gate
const approvedHypothesisCount = await ctx.db.workflowHypothesis.count({
  where: { prospectId: prospect.id, status: 'ACCEPTED' },
});
if (approvedHypothesisCount === 0) {
  results.push({
    prospectId: prospect.id,
    company,
    status: 'blocked_hypothesis',
    runId: research.run.id,
    detail: 'No approved hypothesis — approve at least one before outreach',
  });
  continue;
}
```

Note: Place this check AFTER the research gate (`blocked_gate`) but BEFORE the hypothesis fetch + proof matching. This prevents wasting matchProofs API calls on prospects that will be blocked anyway.

Also update the summary counters at the bottom of runAutopilot. If there is a `blockedGate` counter, add a `blockedHypothesis` counter using the same pattern:

```typescript
blockedHypothesis: results.filter(r => r.status === 'blocked_hypothesis').length,
```

  </action>
  <verify>Run `npx tsc --noEmit` — no type errors in server/routers/assets.ts or server/routers/campaigns.ts. Confirm TRPCError import in assets.ts. Confirm 'blocked_hypothesis' is in the status union in campaigns.ts.</verify>
  <done>queueOutreachDraft throws PRECONDITION_FAILED when no ACCEPTED hypothesis exists. runAutopilot skips and reports blocked_hypothesis for prospects without approved hypotheses.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors in modified files
2. `matchProofs` is imported and called in `hypotheses.ts` regenerateForRun
3. `listByProspect` includes `useCase` and `evidenceItem` in proofMatches
4. `listAll` procedure exists and queries across all prospects
5. `queueOutreachDraft` has PRECONDITION_FAILED gate on approved hypothesis count
6. `runAutopilot` has `blocked_hypothesis` status in per-prospect loop
7. All existing tests still pass: `npm run test`
</verification>

<success_criteria>

- Regenerating hypotheses creates ProofMatch records with matched use cases
- Hypothesis queries return enriched data with evidence and use case information
- Outreach is blocked for prospects without at least one ACCEPTED hypothesis
- Both manual (queueOutreachDraft) and automated (runAutopilot) flows enforce the gate
  </success_criteria>

<output>
After completion, create `.planning/phases/07-evidence-approval-gate/07-01-SUMMARY.md`
</output>
