---
phase: 07-evidence-approval-gate
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/routers/hypotheses.ts
  - server/routers/assets.ts
  - server/routers/campaigns.ts
autonomous: true

must_haves:
  truths:
    - 'Regenerating hypotheses for a research run also creates ProofMatch records linking each hypothesis to matched use cases'
    - 'Querying hypotheses by prospect returns proofMatches with useCase and evidenceItem data, plus evidenceItems resolved from evidenceRefs JSON'
    - 'Querying all hypotheses across prospects returns results with prospect info and proofMatches with useCase data'
    - 'Attempting to queue an outreach draft for a prospect with no ACCEPTED hypothesis throws a PRECONDITION_FAILED TRPCError'
    - 'Running autopilot on a campaign skips prospects with no ACCEPTED hypothesis and reports blocked_hypothesis status'
  artifacts:
    - path: 'server/routers/hypotheses.ts'
      provides: 'regenerateForRun with matchProofs wiring, enriched listByProspect, new listAll procedure'
      contains: 'matchProofs'
    - path: 'server/routers/assets.ts'
      provides: 'Hypothesis approval gate in queueOutreachDraft'
      contains: 'PRECONDITION_FAILED'
    - path: 'server/routers/campaigns.ts'
      provides: 'Hypothesis approval gate in runAutopilot per-prospect loop'
      contains: 'blocked_hypothesis'
  key_links:
    - from: 'server/routers/hypotheses.ts'
      to: 'lib/workflow-engine.ts'
      via: 'matchProofs(ctx.db, query, limit) import'
      pattern: "matchProofs\\(ctx\\.db"
    - from: 'server/routers/assets.ts'
      to: 'WorkflowHypothesis'
      via: 'count query for ACCEPTED status check'
      pattern: "workflowHypothesis\\.count"
    - from: 'server/routers/campaigns.ts'
      to: 'WorkflowHypothesis'
      via: 'count query for ACCEPTED status in per-prospect loop'
      pattern: 'blocked_hypothesis'
---

<objective>
Wire matchProofs into hypothesis regeneration, enrich hypothesis queries with evidence and use case data, and add an outreach gate that blocks sequence generation until at least one hypothesis is approved.

Purpose: This is the backend foundation for Phase 7. Without matchProofs wiring, the review UI will show empty use case matches. Without the gate, outreach can be sent for prospects with no approved hypotheses — violating the core "evidence-backed" principle.

Output: Updated hypotheses router (regenerateForRun + matchProofs, enriched listByProspect, new listAll), hypothesis approval gate in assets.queueOutreachDraft and campaigns.runAutopilot.
</objective>

<execution_context>
@/home/klarifai/.claude/get-shit-done/workflows/execute-plan.md
@/home/klarifai/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-evidence-approval-gate/07-RESEARCH.md
@.planning/phases/06-use-cases-foundation/06-03-SUMMARY.md

@server/routers/hypotheses.ts
@server/routers/assets.ts
@server/routers/campaigns.ts
@server/routers/proof.ts
@lib/workflow-engine.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire matchProofs into regenerateForRun and enrich hypothesis queries</name>
  <files>server/routers/hypotheses.ts</files>
  <action>
Three changes to `server/routers/hypotheses.ts`:

**1. Wire matchProofs into regenerateForRun (both hypotheses AND opportunities):**

Import `matchProofs` from `@/lib/workflow-engine`. The wiring must cover BOTH the hypotheses loop and the opportunities loop, mirroring the pattern in `campaigns.ts` lines 277-331.

**1a. Hypotheses loop:** After each `workflowHypothesis.create()` call inside the `for (const hypothesis of hypotheses)` loop (after line 105), add:

- Store the `.create()` return value (e.g., `const created = await ctx.db.workflowHypothesis.create(...)`)
- Delete existing ProofMatch rows for the newly created hypothesis (defensive, same pattern as `proof.ts` lines 35-46)
- Call `matchProofs(ctx.db, \`${hypothesis.title} ${hypothesis.problemStatement}\`, 4)`
- Create ProofMatch records for each match, linking to the prospect and hypothesis. Use the exact data shape from `campaigns.ts` lines 287-302:
  ```
  { prospectId: run.prospectId, workflowHypothesisId: created.id, sourceType, proofId, proofTitle, proofSummary, proofUrl, score, isRealShipped, isCustomPlan, useCaseId: match.isCustomPlan ? undefined : match.proofId }
  ```

**1b. Opportunities loop:** After each `automationOpportunity.create()` call inside the `for (const opportunity of opportunities)` loop (after line 128), add the same pattern:

- Store the `.create()` return value (e.g., `const createdOpp = await ctx.db.automationOpportunity.create(...)`)
- Delete existing ProofMatch rows: `await ctx.db.proofMatch.deleteMany({ where: { automationOpportunityId: createdOpp.id } })`
- Call `matchProofs(ctx.db, \`${opportunity.title} ${opportunity.description}\`, 4)`
- Create ProofMatch records for each match, linking to the prospect and opportunity. Use the exact data shape from `campaigns.ts` lines 314-330:
  ```
  { prospectId: run.prospectId, automationOpportunityId: createdOpp.id, sourceType, proofId, proofTitle, proofSummary, proofUrl, score, isRealShipped, isCustomPlan, useCaseId: match.isCustomPlan ? undefined : match.proofId }
  ```

Without the opportunities loop wiring, opportunity cards in the review UI will always show empty use case matches.

**2. Enrich listByProspect with evidence + use case data:**

Update `listByProspect` to:

- Change `proofMatches: true` to include useCase and evidenceItem:
  ```typescript
  proofMatches: {
    include: {
      useCase: { select: { id: true, title: true, summary: true, category: true } },
      evidenceItem: { select: { id: true, sourceUrl: true, snippet: true, sourceType: true, workflowTag: true, title: true } },
    },
    orderBy: { score: 'desc' },
    take: 6,
  },
  ```
- After fetching hypotheses and opportunities, extract all evidenceRef IDs from `h.evidenceRefs` (JSON array of strings) and `o.evidenceRefs`, deduplicate, and bulk-fetch EvidenceItem records via `ctx.db.evidenceItem.findMany({ where: { id: { in: dedupedIds } } })`.
- Build an `evidenceById` Map keyed by ID.
- Return enriched results with `evidenceItems` array per hypothesis/opportunity:
  ```typescript
  {
    hypotheses: hypotheses.map(h => ({
      ...h,
      evidenceItems: (Array.isArray(h.evidenceRefs) ? (h.evidenceRefs as string[]) : [])
        .map(id => evidenceById.get(id)).filter(Boolean),
    })),
    opportunities: opportunities.map(o => ({
      ...o,
      evidenceItems: (Array.isArray(o.evidenceRefs) ? (o.evidenceRefs as string[]) : [])
        .map(id => evidenceById.get(id)).filter(Boolean),
    })),
  }
  ```

**3. Add listAll procedure:**

Add a new `listAll` adminProcedure after `listByProspect`. Input: optional `{ status?: 'DRAFT' | 'ACCEPTED' | 'REJECTED', limit?: number (1-200, default 100) }`. Query `workflowHypothesis.findMany` with:

- `where`: filter by status if provided
- `orderBy: { createdAt: 'desc' }`
- `take: input?.limit ?? 100`
- `include`:
  - `prospect: { select: { id: true, companyName: true, domain: true } }`
  - `proofMatches: { include: { useCase: { select: { id: true, title: true, category: true } } }, orderBy: { score: 'desc' }, take: 4 }`
- Return the array directly.

Do NOT add a separate evidenceRefs resolution to listAll — keep it lightweight for the list page. Evidence detail is only needed on the per-prospect detail view (listByProspect).
</action>
<verify>Run `npx tsc --noEmit` — no type errors in server/routers/hypotheses.ts. Confirm matchProofs import resolves. Confirm the file exports hypothesesRouter with listByProspect, listAll, setStatus, and regenerateForRun.</verify>
<done>regenerateForRun creates ProofMatch records after each hypothesis. listByProspect returns proofMatches with useCase + evidenceItem includes and resolved evidenceItems from JSON refs. listAll returns hypotheses with prospect info and proofMatches.</done>
</task>

<task type="auto">
  <name>Task 2: Add hypothesis approval gate to queueOutreachDraft and runAutopilot</name>
  <files>server/routers/assets.ts, server/routers/campaigns.ts</files>
  <action>
**1. Gate in assets.ts — queueOutreachDraft:**

Add `import { TRPCError } from '@trpc/server';` at top of assets.ts (if not already imported).

Inside `queueOutreachDraft` mutation, after the `[map, contact]` fetch (after line 264) and before the `appUrl` line (line 266), add:

```typescript
// Hypothesis approval gate — block outreach unless at least one hypothesis is approved
const approvedHypothesisCount = await ctx.db.workflowHypothesis.count({
  where: { prospectId: map.prospect.id, status: 'ACCEPTED' },
});
if (approvedHypothesisCount === 0) {
  throw new TRPCError({
    code: 'PRECONDITION_FAILED',
    message:
      'Outreach blocked: approve at least one hypothesis before generating sequences.',
  });
}
```

**2. Gate in campaigns.ts — runAutopilot:**

In the `results` type union (around line 207), add `'blocked_hypothesis'` to the status union:

```typescript
status: 'planned' |
  'completed' |
  'blocked_gate' |
  'blocked_hypothesis' |
  'no_hypotheses' |
  'no_contact' |
  'error';
```

**IMPORTANT — gate placement:** The hypothesis approval gate must go BEFORE `executeResearchRun()`, not after it. `executeResearchRun` creates a brand-new research run with fresh DRAFT hypotheses each time. If the gate checked after that call, it would always find zero ACCEPTED hypotheses and block 100% of prospects.

In the per-prospect loop (inside `try` block, BEFORE the `buildDefaultReviewSeedUrls`/`executeResearchRun` calls around line 245), add:

```typescript
// Hypothesis approval gate — must check BEFORE executeResearchRun
// because executeResearchRun creates a new run with DRAFT hypotheses.
// Query by prospectId (across all runs), not by a specific runId.
const approvedHypothesisCount = await ctx.db.workflowHypothesis.count({
  where: { prospectId: prospect.id, status: 'ACCEPTED' },
});
if (approvedHypothesisCount === 0) {
  results.push({
    prospectId: prospect.id,
    company,
    status: 'blocked_hypothesis',
    detail:
      'No approved hypothesis — approve at least one before outreach. Run research first, then approve hypotheses.',
  });
  continue;
}
```

Note: For brand-new prospects that have never had research run (no hypotheses at all), this gate correctly blocks them with `blocked_hypothesis` status. The admin workflow becomes a two-pass flow: Run 1 generates research + hypotheses, admin approves, Run 2 generates outreach. For prospects with pre-existing approved hypotheses, autopilot proceeds normally to research + outreach in a single pass.

Also update the summary counters at the bottom of runAutopilot (around line 621-633). The complete return object must include the new counter alongside all existing ones:

```typescript
return {
  campaignId: campaign.id,
  campaignName: campaign.name,
  dryRun: false,
  scanned: prospects.length,
  completed: results.filter((item) => item.status === 'completed').length,
  blockedGate: results.filter((item) => item.status === 'blocked_gate').length,
  blockedHypothesis: results.filter(
    (item) => item.status === 'blocked_hypothesis',
  ).length,
  noContact: results.filter((item) => item.status === 'no_contact').length,
  failed: results.filter((item) => item.status === 'error').length,
  results,
};
```

  </action>
  <verify>Run `npx tsc --noEmit` — no type errors in server/routers/assets.ts or server/routers/campaigns.ts. Confirm TRPCError import in assets.ts. Confirm 'blocked_hypothesis' is in the status union in campaigns.ts.</verify>
  <done>queueOutreachDraft throws PRECONDITION_FAILED when no ACCEPTED hypothesis exists. runAutopilot skips and reports blocked_hypothesis for prospects without approved hypotheses.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors in modified files
2. `matchProofs` is imported and called in `hypotheses.ts` regenerateForRun
3. `listByProspect` includes `useCase` and `evidenceItem` in proofMatches
4. `listAll` procedure exists and queries across all prospects
5. `queueOutreachDraft` has PRECONDITION_FAILED gate on approved hypothesis count
6. `runAutopilot` has `blocked_hypothesis` status in per-prospect loop
7. All existing tests still pass: `npm run test`
</verification>

<success_criteria>

- Regenerating hypotheses creates ProofMatch records with matched use cases
- Hypothesis queries return enriched data with evidence and use case information
- Outreach is blocked for prospects without at least one ACCEPTED hypothesis
- Both manual (queueOutreachDraft) and automated (runAutopilot) flows enforce the gate
  </success_criteria>

<output>
After completion, create `.planning/phases/07-evidence-approval-gate/07-01-SUMMARY.md`
</output>
